{"version":3,"sources":["../../src/animate/MovieClip.js"],"names":["Container","PIXI","SharedTicker","ticker","shared","MovieClip","options","duration","loop","framerate","labels","undefined","mode","INDEPENDENT","startPosition","Object","assign","currentFrame","_labels","_labelDict","name","label","position","push","sort","a","b","selfAdvance","paused","actionsEnabled","autoReset","_synchOffset","_prevPos","_t","_framerate","_duration","_totalFrames","_timelines","_timedChildTimelines","_depthSorted","_actions","_beforeUpdate","_tickListener","bind","_onAdded","_onRemoved","on","advance","_updateTimeline","_setTimelinePosition","_goto","parentFramerate","add","tickerDeltaTime","seconds","speed","settings","TARGET_FPMS","remove","_autoExtend","endFrame","_parseProperties","properties","t","hexToUint","v","_getChildTimeline","instance","i","length","target","timeline","addTimedMask","keyframes","addKeyframe","m","parseInt","am","addTween","startFrame","ease","at","addTimedChild","SYNCHED","parentStartPosition","fillFrames","deserializeKeyframes","lastFrame","extendLastFrame","aa","callback","addAction","index","actions","ps","alias","playSound","animate","sound","emit","play","stop","gotoAndPlay","positionOrLabel","gotoAndStop","time","Math","floor","afterUpdateOnce","pos","NaN","_reset","synched","SINGLE_FRAME","doActions","j","tween","setPosition","timedChildTimelines","depthSorted","shouldBeChild","parent","addChild","removeChild","currentIndex","children","indexOf","addChildAt","child","needsLoop","min","frameActions","call","destroy","destroyChildren","hiddenChildren","timelines","_currentProps","current","len","value","o","fps","DEFAULT_FRAMERATE","extend","e","prototype","create","__parent","constructor"],"mappings":"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","file":"MovieClip.js","sourcesContent":["import Timeline from './Timeline';\nimport utils from './utils';\n\nconst Container = PIXI.Container;\nconst SharedTicker = PIXI.ticker.shared;\n\n/**\n * Provide timeline playback of movieclip\n * @memberof PIXI.animate\n * @class MovieClip\n * @extends PIXI.Container\n * @constructor\n * @param {Object|int} [options] The options object or the mode to play\n * @param {int} [options.mode=0] The playback mode default is independent (0),\n * @param {int} [options.startPosition=0] The starting frame\n * @param {Boolean} [options.loop=true] If playback is looped\n * @param {Object} [options.labels] The frame labels map of label to frames\n * @param {int} [options.duration] The duration, if no duration is provided, auto determines length\n * @param {int} [options.framerate=24] The framerate to use for independent mode\n */\nclass MovieClip extends Container {\n    constructor(options, duration, loop, framerate, labels) {\n        super();\n\n        // Default options\n        options = options === undefined ? {} : options;\n\n        // Options can also be the mode\n        if (typeof options === 'number') {\n            options = {\n                mode: options || MovieClip.INDEPENDENT,\n                duration: duration || 0,\n                loop: loop === undefined ? true : loop,\n                labels: labels || {},\n                framerate: framerate || 0,\n                startPosition: 0\n            };\n        } else {\n            // Apply defaults to options\n            options = Object.assign({\n                mode: MovieClip.INDEPENDENT,\n                startPosition: 0,\n                loop: true,\n                labels: {},\n                duration: 0,\n                framerate: 0\n            }, options);\n        }\n\n        /**\n         * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).\n         * See each constant for a description of the behaviour.\n         * @name PIXI.animate.MovieClip#mode\n         * @type int\n         * @default null\n         */\n        this.mode = options.mode;\n\n        /**\n         * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.\n         * @name PIXI.animate.MovieClip#startPosition\n         * @type Number\n         * @default 0\n         */\n        this.startPosition = options.startPosition;\n\n        /**\n         * Indicates whether this MovieClip should loop when it reaches the end of its timeline.\n         * @name PIXI.animate.MovieClip#loop\n         * @type Boolean\n         * @default true\n         */\n        this.loop = !!options.loop;\n\n        /**\n         * The current frame of the movieclip.\n         * @name PIXI.animate.MovieClip#currentFrame\n         * @type Number\n         * @default 0\n         * @readOnly\n         */\n        this.currentFrame = 0;\n\n        /**\n         * The collection of private labels\n         * @name PIXI.animate.MovieClip#_labels\n         * @type Array\n         * @private\n         */\n        this._labels = [];\n\n        /**\n         * The collection of private labels\n         * @name PIXI.animate.MovieClip#_labelDict\n         * @type Object\n         * @private\n         */\n        this._labelDict = options.labels;\n        if (options.labels) {\n            for (let name in options.labels) {\n                let label = {\n                    label: name,\n                    position: options.labels[name]\n                };\n                this._labels.push(label);\n            }\n            this._labels.sort(function(a, b) {\n                return a.position - b.position;\n            });\n        }\n\n        /**\n         * If true, this movieclip will animate automatically whenever it is on the stage.\n         * @name PIXI.animate.MovieClip#selfAdvance\n         * @type Boolean\n         * @default true\n         */\n        this.selfAdvance = true;\n\n        /**\n         * If true, the MovieClip's position will not advance when ticked.\n         * @name PIXI.animate.MovieClip#paused\n         * @type Boolean\n         * @default false\n         */\n        this.paused = false;\n\n        /**\n         * If true, actions in this MovieClip's tweens will be run when the playhead advances.\n         * @name PIXI.animate.MovieClip#actionsEnabled\n         * @type Boolean\n         * @default true\n         */\n        this.actionsEnabled = true;\n\n        /**\n         * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds\n         * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.\n         * <br><br>\n         * For example, if you had a character animation with a 'body' child MovieClip instance\n         * with different costumes on each frame, you could set body.autoReset = false, so that\n         * you can manually change the frame it is on, without worrying that it will be reset\n         * automatically.\n         * @name PIXI.animate.MovieClip#autoReset\n         * @type Boolean\n         * @default true\n         */\n        this.autoReset = true;\n\n        /**\n         * @name PIXI.animate.MovieClip#_synchOffset\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._synchOffset = 0;\n\n        /**\n         * @name PIXI.animate.MovieClip#_prevPos\n         * @type Number\n         * @default -1\n         * @private\n         */\n        this._prevPos = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.\n\n        /**\n         * Note - changed from default: When the MovieClip is framerate independent, this is the time\n         * elapsed from frame 0 in seconds.\n         * @name PIXI.animate.MovieClip#_t\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._t = 0;\n\n        /**\n         * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n         * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n         * framerate.\n         *\n         * @name PIXI.animate.MovieClip#_framerate\n         * @type {Number}\n         * @default 0\n         * @protected\n         */\n        this._framerate = options.framerate;\n\n        /**\n         * The total time in seconds for the animation. This is changed when setting the framerate.\n         * @name PIXI.animate.MovieClip#_duration\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._duration = 0;\n\n        /**\n         * The total duration in frames for the animation.\n         * @name PIXI.animate.MovieClip#_totalFrames\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._totalFrames = options.duration;\n\n        /**\n         * Standard tween timelines for all objects. Each element in the _timelines array\n         * is a Timeline object - an array of tweens for one target, in order of occurrence.\n         * @name PIXI.animate.MovieClip#_timelines\n         * @type Array\n         * @protected\n         */\n        this._timelines = [];\n\n        /**\n         * Array of child timelines denoting if a child is actively a child of this movieclip\n         * on any given frame. Each element in the _timedChildTimelines is an array with a 'target'\n         * property, and is an array of boolean values indexed by frame.\n         * @name PIXI.animate.MovieClip#_timedChildTimelines\n         * @type {Array}\n         * @protected\n         */\n        this._timedChildTimelines = [];\n\n        /**\n         * Array to depth sort timed children\n         * @name PIXI.animate.MovieClip#_depthSorted\n         * @type {Array}\n         * @private\n         */\n        this._depthSorted = [];\n\n        /**\n         * Array of frame scripts, indexed by frame.\n         * @name PIXI.animate.MovieClip#_actions\n         * @type {Array}\n         * @protected\n         */\n        this._actions = [];\n\n        /**\n         * Optional callback fired before timeline is updated.\n         * Can be used to clamp or update the currentFrame.\n         * @name PIXI.animate.MovieClip#_beforeUpdate\n         * @type {Function}\n         * @private\n         */\n        this._beforeUpdate = null;\n\n        if (this.mode === MovieClip.INDEPENDENT) {\n            this._tickListener = this._tickListener.bind(this);\n            this._onAdded = this._onAdded.bind(this);\n            this._onRemoved = this._onRemoved.bind(this);\n            this.on('added', this._onAdded);\n            this.on('removed', this._onRemoved);\n        }\n\n        if (options.framerate) {\n            this.framerate = options.framerate;\n        }\n\n        //save often used methods on the instance so that they can be fetched slightly faster\n        //than if they had to be fetched from the prototype\n        this.advance = this.advance;\n        this._updateTimeline = this._updateTimeline;\n        this._setTimelinePosition = this._setTimelinePosition;\n        this._goto = this._goto;\n    }\n\n    _onAdded() {\n        if (!this._framerate) {\n            this.framerate = this.parentFramerate;\n        }\n        SharedTicker.add(this._tickListener);\n    }\n\n    _tickListener(tickerDeltaTime) {\n        if (this.paused || !this.selfAdvance) {\n            //see if the movieclip needs to be updated even though it isn't animating\n            if (this._prevPos < 0) {\n                this._goto(this.currentFrame);\n            }\n            return;\n        }\n        let seconds = tickerDeltaTime / SharedTicker.speed / PIXI.settings.TARGET_FPMS / 1000;\n        this.advance(seconds);\n    }\n\n    _onRemoved() {\n        SharedTicker.remove(this._tickListener);\n    }\n\n    /**\n     * Returns an array of objects with label and position (aka frame) properties, sorted by position.\n     * @name PIXI.animate.MovieClip#labels\n     * @type {Array}\n     * @readonly\n     */\n    get labels() {\n        return this._labels;\n    }\n\n    /**\n     * Returns a dictionary of labels where key is the label and value is the frame.\n     * @name PIXI.animate.MovieClip#labelsMap\n     * @type {Object}\n     * @readonly\n     */\n    get labelsMap() {\n        return this._labelDict;\n    }\n\n    /**\n     * Returns the name of the label on or immediately before the current frame.\n     * @name PIXI.animate.MovieClip#currentLabel\n     * @type {String}\n     * @readonly\n     */\n    get currentLabel() {\n        let labels = this._labels;\n        let current = null;\n        for (let i = 0, len = labels.length; i < len; ++i) {\n            if (labels[i].position <= this.currentFrame) {\n                current = labels[i].label;\n            } else {\n                break;\n            }\n        }\n        return current;\n    }\n\n    /**\n     * When the MovieClip is framerate independent, this is the time elapsed from frame 0 in seconds.\n     * @name PIXI.animate.MovieClip#elapsedTime\n     * @type Number\n     * @default 0\n     * @public\n     */\n    get elapsedTime() {\n        return this._t;\n    }\n\n    set elapsedTime(value) {\n        this._t = value;\n    }\n\n    /**\n     * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n     * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n     * framerate.\n     *\n     * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will\n     * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n     * vary slightly between frames.\n     *\n     * This feature is dependent on the tick event object (or an object with an appropriate 'delta' property) being\n     * passed into {{#crossLink 'Stage/update'}}{{/crossLink}}.\n     * @name PIXI.animate.MovieClip#framerate\n     * @type {Number}\n     * @default 0\n     */\n    get framerate() {\n        return this._framerate;\n    }\n    set framerate(value) {\n        if (value > 0) {\n            this._framerate = value;\n            this._duration = value ? this._totalFrames / value : 0;\n            this._t = this.currentFrame / value;\n        } else {\n            this._t = this._framerate = this._duration = 0;\n        }\n    }\n\n    /**\n     * Get the total number of frames (duration) of this MovieClip\n     * @name PIXI.animate.MovieClip#totalFrames\n     * @type {Number}\n     * @default 0\n     * @readOnly\n     */\n    get totalFrames() {\n        return this._totalFrames;\n    }\n\n    /**\n     * Extend the timeline to the last frame.\n     * @method PIXI.animate.MovieClip#_autoExtend\n     * @private\n     * @param {int} endFrame\n     */\n    _autoExtend(endFrame) {\n        if (this._totalFrames < endFrame) {\n            this._totalFrames = endFrame;\n        }\n    }\n\n    /**\n     * Convert values of properties\n     * @method PIXI.animate.MovieClip#_parseProperties\n     * @private\n     * @param {Object} properties\n     */\n    _parseProperties(properties) {\n        // Convert any string colors to uints\n        if (typeof properties.t === 'string') {\n            properties.t = utils.hexToUint(properties.t);\n        } else if (typeof properties.v === 'number') {\n            properties.v = !!properties.v;\n        }\n    }\n\n    /**\n     * Get a timeline for a child, synced timeline.\n     * @method PIXI.animate.MovieClip#_getChildTimeline\n     * @private\n     * @param {PIXI.animate.MovieClip} instance\n     * @return {PIXI.animate.Timeline}\n     */\n    _getChildTimeline(instance) {\n        for (let i = this._timelines.length - 1; i >= 0; --i) {\n            if (this._timelines[i].target === instance) {\n                return this._timelines[i];\n            }\n        }\n        let timeline = new Timeline(instance);\n        this._timelines.push(timeline);\n        return timeline;\n    }\n\n    /**\n     * Add mask or masks\n     * @method PIXI.animate.MovieClip#addTimedMask\n     * @param {PIXI.DisplayObject} instance Instance to mask\n     * @param {Object} keyframes The map of frames to mask objects\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\n     */\n    addTimedMask(instance, keyframes) {\n        for (let i in keyframes) {\n            this.addKeyframe(instance, {\n                m: keyframes[i]\n            }, parseInt(i, 10));\n        }\n\n        // Set the initial position/add\n        this._setTimelinePosition(this.currentFrame, this.currentFrame, true);\n        return this;\n    }\n\n    /**\n     * Shortcut alias for `addTimedMask`\n     * @method PIXI.animate.MovieClip#am\n     * @param {PIXI.DisplayObject} instance Instance to mask\n     * @param {Object} keyframes The map of frames to mask objects\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\n     */\n    am(instance, keyframes) {\n        return this.addTimedMask(instance, keyframes);\n    }\n\n    /**\n     * Add a tween to the clip\n     * @method PIXI.animate.MovieClip#addTween\n     * @param {PIXI.DisplayObject} instance The clip to tween\n     * @param {Object} properties The property or property to tween\n     * @param {int} startFrame The frame to start tweening\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\n     *                           with no tweening.\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\n     * @return {PIXI.animate.MovieClip}\n     */\n    addTween(instance, properties, startFrame, duration, ease) {\n\n        let timeline = this._getChildTimeline(instance);\n        this._parseProperties(properties);\n        timeline.addTween(properties, startFrame, duration, ease);\n        this._autoExtend(startFrame + duration);\n        return this;\n    }\n\n    /**\n     * Add a tween to the clip\n     * @method PIXI.animate.MovieClip#addKeyframe\n     * @param {PIXI.DisplayObject} instance The clip to tween\n     * @param {Object} properties The property or property to tween\n     * @param {int} startFrame The frame to start tweening\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\n     *                           with no tweening.\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\n     * @return {PIXI.animate.MovieClip}\n     */\n    addKeyframe(instance, properties, startFrame) {\n\n        let timeline = this._getChildTimeline(instance);\n        this._parseProperties(properties);\n        timeline.addKeyframe(properties, startFrame);\n        this._autoExtend(startFrame);\n        return this;\n    }\n\n    /**\n     * Alias for method `addTimedChild`\n     * @method PIXI.animate.MovieClip#at\n     * @return {PIXI.animate.MovieClip}\n     */\n    at(instance, startFrame, duration, keyframes) {\n        return this.addTimedChild(instance, startFrame, duration, keyframes);\n    }\n\n    /**\n     * Add a child to show for a certain number of frames before automatic removal.\n     * @method PIXI.animate.MovieClip#addTimedChild\n     * @param {PIXI.DisplayObject} instance The clip to show\n     * @param {int} startFrame The starting frame\n     * @param {int} [duration=1] The number of frames to display the child before removing it.\n     * @param {String|Array} [keyframes] The collection of static keyframes to add\n     * @return {PIXI.animate.MovieClip}\n     */\n    addTimedChild(instance, startFrame, duration, keyframes) {\n\n        if (startFrame === undefined) // jshint ignore:line\n        {\n            startFrame = 0;\n        }\n        if (duration === undefined || duration < 1) // jshint ignore:line\n        {\n            duration = this._totalFrames || 1;\n        }\n\n        // Add the starting offset for synced movie clips\n        if (instance.mode === MovieClip.SYNCHED) {\n            instance.parentStartPosition = startFrame;\n        }\n\n        //add tweening info about this child's presence on stage\n        //when the child is (re)added, if it has 'autoReset' set to true, then it\n        //should be set back to frame 0\n        let timeline, i;\n        //get existing timeline\n        for (i = this._timedChildTimelines.length - 1; i >= 0; --i) {\n            if (this._timedChildTimelines[i].target === instance) {\n                timeline = this._timedChildTimelines[i];\n                break;\n            }\n        }\n        //if there wasn't one, make a new one\n        if (!timeline) {\n            timeline = [];\n            timeline.target = instance;\n            this._timedChildTimelines.push(timeline);\n        }\n\n        // Fill the timeline with keyframe booleans\n        utils.fillFrames(timeline, startFrame, duration);\n\n        // Update the total frames if the instance extends our current\n        // total frames for this movieclip\n        if (this._totalFrames < startFrame + duration) {\n            this._totalFrames = startFrame + duration;\n        }\n\n        // Add the collection of keyframes\n        if (keyframes) {\n            if (typeof keyframes === \"string\") {\n                keyframes = utils.deserializeKeyframes(keyframes);\n            }\n            // Convert the keyframes object into\n            // individual properties\n            let lastFrame = {};\n            for (let i in keyframes) {\n                lastFrame = Object.assign({}, lastFrame, keyframes[i]);\n                this.addKeyframe(instance, lastFrame, parseInt(i, 10));\n            }\n            this._getChildTimeline(instance)\n                .extendLastFrame(startFrame + duration);\n        }\n\n        // Set the initial position/add\n        this._setTimelinePosition(startFrame, this.currentFrame, true);\n\n        return this;\n    }\n\n    /**\n     * Short cut for `addAction`\n     * @method PIXI.animate.MovieClip#aa\n     * @param {Function} callback The clip call on a certain frame\n     * @param {int|String} startFrame The starting frame index or label\n     * @return {PIXI.animate.MovieClip}\n     */\n    aa(callback, startFrame) {\n        return this.addAction(callback, startFrame);\n    }\n\n    /**\n     * Handle frame actions, callback is bound to the instance of the MovieClip.\n     * @method PIXI.animate.MovieClip#addAction\n     * @param {Function} callback The clip call on a certain frame\n     * @param {int|String} startFrame The starting frame index or label\n     * @return {PIXI.animate.MovieClip}\n     */\n    addAction(callback, startFrame) {\n\n        if (typeof startFrame === 'string') {\n            const index = this._labelDict[startFrame];\n            if (index === undefined) {\n                throw `The label '${startFrame}' does not exist on this timeline`;\n            }\n            startFrame = index;\n        }\n\n        let actions = this._actions;\n        //ensure that the movieclip timeline is long enough to support the target frame\n        if (actions.length <= startFrame) {\n            actions.length = startFrame + 1;\n        }\n        if (this._totalFrames < startFrame) {\n            this._totalFrames = startFrame;\n        }\n        //add the action\n        if (actions[startFrame]) {\n            actions[startFrame].push(callback);\n        } else {\n            actions[startFrame] = [callback];\n        }\n        return this;\n    }\n\n    /**\n     * Short cut for `playSound`\n     * @method PIXI.animate.MovieClip#ps\n     * @param {String} alias The name of the Sound\n     * @param {Boolean} [loop=false] The loop property of the sound\n     * @param {MovieClip} context The MovieClip the sound originates from\n     * @return {PIXI.animate.MovieClip}\n     */\n    ps(alias, loop) {\n        return this.playSound(alias, loop);\n    }\n\n    /**\n     * Handle sounds.\n     * @method PIXI.animate.MovieClip#playSound\n     * @param {String} alias The name of the Sound\n     * @param {Boolean} [loop=false] The loop property of the sound\n     * @param {MovieClip} context The MovieClip the sound originates from\n     * @return {PIXI.animate.MovieClip}\n     */\n    playSound(alias, loop) {\n        PIXI.animate.sound.emit('play', alias, !!loop, this);\n        return this;\n    }\n\n    /**\n     * Sets paused to false.\n     * @method PIXI.animate.MovieClip#play\n     */\n    play() {\n        this.paused = false;\n    }\n\n    /**\n     * Sets paused to true.\n     * @method PIXI.animate.MovieClip#stop\n     */\n    stop() {\n        this.paused = true;\n    }\n\n    /**\n     * Advances this movie clip to the specified position or label and sets paused to false.\n     * @method PIXI.animate.MovieClip#gotoAndPlay\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n     */\n    gotoAndPlay(positionOrLabel) {\n        this.paused = false;\n        this._goto(positionOrLabel);\n    }\n\n    /**\n     * Advances this movie clip to the specified position or label and sets paused to true.\n     * @method PIXI.animate.MovieClip#gotoAndStop\n     * @param {String|Number} positionOrLabel The animation or frame name to go to.\n     */\n    gotoAndStop(positionOrLabel) {\n        this.paused = true;\n        this._goto(positionOrLabel);\n    }\n\n    /**\n     * Get the close parent with a valid framerate. If no parent, returns the default framerate.\n     * @name PIXI.animate.MovieClip#parentFramerate\n     * @type {Number}\n     * @readOnly\n     */\n    get parentFramerate() {\n        let o = this,\n            fps = o._framerate;\n        while ((o = o.parent) && !fps) {\n            if (o.mode === MovieClip.INDEPENDENT) {\n                fps = o._framerate;\n            }\n        }\n        return fps || MovieClip.DEFAULT_FRAMERATE;\n    }\n\n    /**\n     * Advances the playhead. This occurs automatically each tick by default.\n     * @method PIXI.animate.MovieClip#advance\n     * @param [time] {Number} The amount of time in seconds to advance by. Only applicable if framerate is set.\n     */\n    advance(time) {\n\n        // Handle any other cases where starting to play\n        // and no framerate has been set yet\n        if (!this._framerate) {\n            this.framerate = this.parentFramerate;\n        }\n\n        if (time) {\n            this._t += time;\n        }\n        if (this._t > this._duration) {\n            this._t = this.loop ? this._t - this._duration : this._duration;\n        }\n        //add a tiny amount to account for potential floating point errors\n        this.currentFrame = Math.floor(this._t * this._framerate + 0.00000001);\n        //final error checking\n        if (this.currentFrame >= this._totalFrames) {\n            this.currentFrame = this._totalFrames - 1;\n        }\n        let afterUpdateOnce;\n        if (this._beforeUpdate) {\n            afterUpdateOnce = this._beforeUpdate(this);\n        }\n        //update all tweens & actions in the timeline\n        this._updateTimeline();\n\n        // Do the animator callback here\n        if (afterUpdateOnce) {\n            afterUpdateOnce();\n        }\n    }\n\n    /**\n     * @method PIXI.animate.MovieClip#_goto\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n     * @protected\n     */\n    _goto(positionOrLabel) {\n        let pos = typeof positionOrLabel === 'string' ? this._labelDict[positionOrLabel] : positionOrLabel;\n        if (pos === undefined) // jshint ignore:line\n        {\n            return;\n        }\n        // prevent _updateTimeline from overwriting the new position because of a reset:\n        this._prevPos = NaN;\n        this.currentFrame = pos;\n\n        // Handle the case where trying to play but haven't\n        // added to the stage yet\n        if (!this._framerate) {\n            this.framerate = this.parentFramerate;\n        }\n\n        //update the elapsed time if a time based movieclip\n        if (this._framerate > 0) {\n            this._t = pos / this._framerate;\n        } else {\n            this._t = 0;\n        }\n        this._updateTimeline();\n    }\n\n    /**\n     * @method PIXI.animate.MovieClip#_reset\n     * @private\n     */\n    _reset() {\n        this._prevPos = -1;\n        this._t = 0;\n        this.currentFrame = 0;\n    }\n\n    /**\n     * @method PIXI.animate.MovieClip#_updateTimeline\n     * @protected\n     */\n    _updateTimeline() {\n        let synched = this.mode !== MovieClip.INDEPENDENT;\n\n        if (synched) {\n            this.currentFrame = this.startPosition + (this.mode === MovieClip.SINGLE_FRAME ? 0 : this._synchOffset);\n            if (this.currentFrame >= this._totalFrames) {\n                this.currentFrame %= this._totalFrames;\n            }\n        }\n\n        if (this._prevPos === this.currentFrame) {\n            return;\n        }\n\n        // update timeline position, ignoring actions if this is a graphic.\n        this._setTimelinePosition(this._prevPos, this.currentFrame, synched ? false : this.actionsEnabled);\n\n        this._prevPos = this.currentFrame;\n    }\n\n    /**\n     * Set the timeline position\n     * @method PIXI.animate.MovieClip#_setTimelinePosition\n     * @protected\n     * @param {int} startFrame\n     * @param {int} currentFrame\n     * @param {Boolean} doActions\n     */\n    _setTimelinePosition(startFrame, currentFrame, doActions) {\n        //handle all tweens\n        let i, j, length, _timelines = this._timelines;\n        for (i = _timelines.length - 1; i >= 0; --i) {\n            let timeline = _timelines[i];\n            for (j = 0, length = timeline.length; j < length; ++j) {\n                let tween = timeline[j];\n                //if the tween contains part of the timeline that we are travelling through\n                if (currentFrame >= tween.startFrame &&\n                    currentFrame <= tween.endFrame) {\n                    // set the position within that tween\n                    //and break the loop to move onto the next timeline\n                    tween.setPosition(currentFrame);\n                    break;\n                }\n            }\n        }\n\n        let timedChildTimelines = this._timedChildTimelines;\n        let depthSorted = this._depthSorted;\n        for (i = 0, length = timedChildTimelines.length; i < length; ++i) {\n            let target = timedChildTimelines[i].target;\n            let shouldBeChild = timedChildTimelines[i][currentFrame];\n            //if child should be on stage and is not:\n            if (shouldBeChild) {\n                // Add to the depthSorted object so we can\n                // check that items are property drawn later\n                depthSorted.push(target);\n                if (target.parent !== this) {\n                    // add the target if it's not there already\n                    this.addChild(target);\n                    if (target.mode === MovieClip.INDEPENDENT && target.autoReset) {\n                        target._reset();\n                    }\n                }\n            } else if (!shouldBeChild && target.parent === this) {\n                this.removeChild(target);\n            }\n        }\n\n        // Properly depth sort the children\n        for (i = 0, length = depthSorted.length; i < length; i++) {\n            let target = depthSorted[i];\n            let currentIndex = this.children.indexOf(target);\n            if (currentIndex !== i) {\n                this.addChildAt(target, i);\n            }\n        }\n\n        // Clear the temporary depth sorting array\n        depthSorted.length = 0;\n\n        //go through all children and update synched movieclips that are not single frames\n        let children = this.children,\n            child;\n        for (i = 0, length = children.length; i < length; ++i) {\n            child = children[i];\n            if (child.mode === MovieClip.SYNCHED) {\n                child._synchOffset = currentFrame - child.parentStartPosition;\n                child._updateTimeline();\n            }\n        }\n\n        //handle actions\n        if (doActions) {\n            let actions = this._actions;\n            //handle looping around\n            let needsLoop = false;\n            if (currentFrame < startFrame) {\n                length = actions.length;\n                needsLoop = true;\n            } else {\n                length = Math.min(currentFrame + 1, actions.length);\n            }\n            for (i = startFrame >= 0 ? startFrame + 1 : currentFrame; i < length; ++i) {\n                if (actions[i]) {\n                    let frameActions = actions[i];\n                    for (j = 0; j < frameActions.length; ++j) {\n                        frameActions[j].call(this);\n                    }\n                }\n                //handle looping around\n                if (needsLoop && i === length - 1) {\n                    i = 0;\n                    length = currentFrame + 1;\n                    needsLoop = false;\n                }\n            }\n        }\n    }\n\n    destroy(destroyChildren) {\n        if (this._tickListener) {\n            SharedTicker.remove(this._tickListener);\n            this._tickListener = null;\n        }\n        const hiddenChildren = [];\n        let timelines = this._timelines;\n        if (timelines) {\n            for (let i = 0; i < timelines.length; i++) {\n                const timeline = timelines[i];\n                hiddenChildren.push(timeline.target);\n                timeline._currentProps = null;\n                timeline.length = 0;\n            }\n        }\n        timelines = this._timedChildTimelines;\n        if (timelines) {\n            for (let i = 0; i < timelines.length; i++) {\n                const timeline = timelines[i];\n                if (hiddenChildren.indexOf(timeline.target) < 0) {\n                    hiddenChildren.push(timeline.target);\n                }\n                timeline._currentProps = null;\n                timeline.length = 0;\n            }\n        }\n        // Destroy all the children\n        for (let i = 0; i < hiddenChildren.length; i++) {\n            // Don't destroy children in the display list\n            if (this.children.indexOf(hiddenChildren[i]) < 0) {\n                hiddenChildren[i].destroy(destroyChildren);\n            }\n        }\n        hiddenChildren.length = 0;\n        this._actions = null;\n        this._timelines = null;\n        this._depthSorted = null;\n        this._timedChildTimelines = null;\n        this._beforeUpdate = null;\n        this._labels = null;\n        this._labelDict = null;\n        super.destroy(destroyChildren);\n    }\n}\n\n/**\n * The MovieClip will advance independently of its parent, even if its parent is paused.\n * This is the default mode.\n * @name PIXI.animate.MovieClip.INDEPENDENT\n * @static\n * @type String\n * @default 0\n * @readonly\n */\nMovieClip.INDEPENDENT = 0;\n\n/**\n * The MovieClip will only display a single frame (as determined by the startPosition property).\n * @name PIXI.animate.MovieClip.SINGLE_FRAME\n * @static\n * @type String\n * @default 1\n * @readonly\n */\nMovieClip.SINGLE_FRAME = 1;\n\n/**\n * The MovieClip will be advanced only when its parent advances and will be synched to the position of\n * the parent MovieClip.\n * @name PIXI.animate.MovieClip.SYNCHED\n * @static\n * @type String\n * @default 2\n * @readonly\n */\nMovieClip.SYNCHED = 2;\n\n\n/**\n * The default framerate if none is specified or there's not parent clip with a framerate.\n * @name PIXI.animate.MovieClip.DEFAULT_FRAMERATE\n * @static\n * @type Number\n * @default 24\n * @readonly\n */\nMovieClip.DEFAULT_FRAMERATE = 24;\n\n/**\n * Extend a container\n * @method PIXI.animate.MovieClip.extend\n * @static\n * @param {PIXI.animate.MovieClip} child The child function\n * @return {PIXI.animate.MovieClip} The child\n */\n/**\n * Extend a container (alias for `extend`)\n * @method PIXI.animate.MovieClip.e\n * @static\n * @param {PIXI.animate.MovieClip} child The child function\n * @return {PIXI.animate.MovieClip} The child\n */\nMovieClip.extend = MovieClip.e = function(child) {\n    child.prototype = Object.create(MovieClip.prototype);\n    child.prototype.__parent = MovieClip.prototype;\n    child.prototype.constructor = child;\n    return child;\n};\n\n// Assign to namespace\nexport default MovieClip;"]}