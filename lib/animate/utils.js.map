{"version":3,"sources":["../../src/animate/utils.js"],"names":["_prepare","AnimateUtils","hexToUint","hex","substr","length","replace","parseInt","fillFrames","timeline","startFrame","duration","oldLength","fill","i","deserializeKeyframes","keyframes","result","keysMap","X","Y","A","B","C","D","R","L","T","F","V","c","buffer","isFrameStarted","prop","frame","parseValue","deserializeShapes","str","shapes","split","isCommand","shape","j","arg","test","parseFloat","push","forEach","val","upload","renderer","displayObject","done","plugins","prepare","register","addMovieClips","item","PIXI","animate","MovieClip","_timedChildTimelines","index","children","indexOf","target","add"],"mappings":"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","file":"utils.js","sourcesContent":["// If the movieclip plugin is installed\nlet _prepare = null;\n\n/**\n * @namespace PIXI.animate.utils\n * @description For keyframe conversions\n */\nexport default class AnimateUtils {\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     * @static\n     * @method PIXI.animate.utils.hexToUint\n     */\n    static hexToUint(hex) {\n        // Remove the hash\n        hex = hex.substr(1);\n\n        // Convert shortcolors fc9 to ffcc99\n        if (hex.length === 3) {\n            hex = hex.replace(/([a-f0-9])/g, '$1$1');\n        }\n        return parseInt(hex, 16);\n    }\n\n    /** \n     * Fill frames with booleans of true (showing) and false (hidden).\n     * @static\n     * @method PIXI.animate.utils.fillFrames\n     * @param {Array<Boolean>} timeline\n     * @param {int} startFrame The start frame when the timeline shows up\n     * @param {int} duration The length of showing\n     */\n    static fillFrames(timeline, startFrame, duration) {\n        //ensure that the timeline is long enough\n        const oldLength = timeline.length;\n        if (oldLength < startFrame + duration) {\n            timeline.length = startFrame + duration;\n            //fill any gaps with false to denote that the child should be removed for a bit\n            if (oldLength < startFrame) {\n                //if the browser has implemented the ES6 fill() function, use that\n                if (timeline.fill) {\n                    timeline.fill(false, oldLength, startFrame);\n                } else {\n                    //if we can't use fill, then do a for loop to fill it\n                    for (let i = oldLength; i < startFrame; ++i) {\n                        timeline[i] = false;\n                    }\n                }\n            }\n        }\n        //if the browser has implemented the ES6 fill() function, use that\n        if (timeline.fill) {\n            timeline.fill(true, startFrame, startFrame + duration);\n        } else {\n            const length = timeline.length;\n            //if we can't use fill, then do a for loop to fill it\n            for (let i = startFrame; i < length; ++i) {\n                timeline[i] = true;\n            }\n        }\n    }\n\n    /**\n     * Convert serialized array into keyframes\n     * `\"0x100y100 1x150\"` to: `{ \"0\": {\"x\":100, \"y\": 100}, \"1\": {\"x\": 150} }`\n     * @static\n     * @method PIXI.animate.utils.deserializeKeyframes\n     * @param {String} keyframes\n     * @param {Object} Resulting keyframes\n     */\n    static deserializeKeyframes(keyframes) {\n        let result = {};\n        let i = 0;\n        let keysMap = {\n            X: 'x', // x position\n            Y: 'y', // y position\n            A: 'sx', // scale x\n            B: 'sy', // scale y\n            C: 'kx', // skew x\n            D: 'ky', // skew y\n            R: 'r', // rotation\n            L: 'a', // alpha\n            T: 't', // tint\n            F: 'c', // colorTransform\n            V: 'v' // visibility\n        };\n        let c,\n            buffer = '',\n            isFrameStarted = false,\n            prop,\n            frame = {};\n\n        while (i <= keyframes.length) {\n            c = keyframes[i];\n            if (keysMap[c]) {\n                if (!isFrameStarted) {\n                    isFrameStarted = true;\n                    result[buffer] = frame;\n                }\n                if (prop) {\n                    frame[prop] = this.parseValue(prop, buffer);\n                }\n                prop = keysMap[c];\n                buffer = '';\n                i++;\n            }\n            // Start a new prop\n            else if (!c || c === ' ') {\n                i++;\n                frame[prop] = this.parseValue(prop, buffer);\n                buffer = '';\n                prop = null;\n                frame = {};\n                isFrameStarted = false;\n            } else {\n                buffer += c;\n                i++;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Convert serialized shapes into draw commands for PIXI.Graphics.\n     * @static\n     * @method PIXI.animate.utils.deserializeShapes\n     * @param {String} str\n     * @param {Array} Resulting shapes map\n     */\n    static deserializeShapes(str) {\n        const result = [];\n        // each shape is a new line\n        let shapes = str.split(\"\\n\");\n        let isCommand = /^[a-z]{1,2}$/;\n        for (let i = 0; i < shapes.length; i++) {\n            let shape = shapes[i].split(' '); // arguments are space separated\n            for (let j = 0; j < shape.length; j++) {\n                // Convert all numbers to floats, ignore colors\n                let arg = shape[j];\n                if (arg[0] !== '#' && !isCommand.test(arg)) {\n                    shape[j] = parseFloat(arg);\n                }\n            }\n            result.push(shape);\n        }\n        return result;\n    }\n\n    /** \n     * Parse the value of the compressed keyframe.\n     * @method PIXI.animate.utils.parseValue\n     * @static\n     * @private\n     * @param {String} prop The property key\n     * @param {String} buffer The contents\n     * @return {*} The parsed value\n     */\n    static parseValue(prop, buffer) {\n        switch (prop) {\n            // Color transforms are parsed as an array\n            case 'c':\n                {\n                    buffer = buffer.split(',');\n                    buffer.forEach(function(val, i, buffer) {\n                        buffer[i] = parseFloat(val);\n                    });\n                    return buffer;\n                }\n                // Tint value should not be converted\n                // can be color uint or string\n            case 't':\n                {\n                    return buffer;\n                }\n                // The visiblity parse as boolean\n            case 'v':\n                {\n                    return !!parseInt(buffer);\n                }\n                // Everything else parse a floats\n            default:\n                {\n                    return parseFloat(buffer);\n                }\n        }\n    }\n\n    /** \n     * Upload all the textures and graphics to the GPU. \n     * @method PIXI.animate.utils.upload\n     * @static\n     * @param {PIXI.WebGLRenderer} renderer Render to upload to\n     * @param {PIXI.DisplayObject} clip MovieClip to upload\n     * @param {function} done When complete\n     */\n    static upload(renderer, displayObject, done) {\n        if (!_prepare) {\n            _prepare = renderer.plugins.prepare;\n            _prepare.register(this.addMovieClips);\n        }\n        _prepare.upload(displayObject, done);\n    }\n\n    /**\n     * Add movie clips to the upload prepare.\n     * @method PIXI.animate.utils.addMovieClips\n     * @static\n     * @private\n     * @param {*} item To add to the queue \n     */\n    static addMovieClips(item) {\n        if (item instanceof PIXI.animate.MovieClip) {\n            item._timedChildTimelines.forEach((timeline) => {\n                const index = item.children.indexOf(timeline.target);\n                if (index === -1) {\n                    _prepare.add(timeline.target);\n                }\n            });\n            return true;\n        }\n        return false;\n    }\n}"]}