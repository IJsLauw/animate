{"version":3,"sources":["../../src/animate/AnimatorTimeline.js"],"names":["pool","AnimatorTimeline","_update","update","bind","init","instance","start","end","loop","callback","gotoAndStop","_beforeUpdate","destroy","_pool","push","completed","currentFrame","_updateTimeline","gotoAndPlay","stop","PIXI","animate","Animator","_internalStop","create","timeline","length","pop","progress","Math","max","min","module","exports"],"mappings":";;;;;;AAAA,IAAMA,OAAO,EAAb;;AAEA;;;;;;IAKMC,gB;AACF,gCAAc;AAAA;;AACV,aAAKC,OAAL,GAAe,KAAKC,MAAL,CAAYC,IAAZ,CAAiB,IAAjB,CAAf;AACA,aAAKC,IAAL,CAAU,IAAV,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,KAAtB,EAA6B,IAA7B;AACH;;AAED;;;;;;;;;;;;+BAUAA,I,iBAAKC,Q,EAAUC,K,EAAOC,G,EAAKC,I,EAAMC,Q,EAAU;;AAEvC;;;;;;AAMA,aAAKJ,QAAL,GAAgBA,QAAhB;;AAEA;;;;;;AAMA,aAAKG,IAAL,GAAYA,IAAZ;;AAEA;;;;;;AAMA,aAAKF,KAAL,GAAaA,KAAb;;AAEA;;;;;;AAMA,aAAKC,GAAL,GAAWA,GAAX;;AAEA;;;;;;AAMA,aAAKE,QAAL,GAAgBA,QAAhB;;AAEA,YAAIJ,QAAJ,EAAc;AACVA,qBAASK,WAAT,CAAqBJ,KAArB;AACAD,qBAASM,aAAT,GAAyB,KAAKV,OAA9B;AACH;AACJ,K;;AAED;;;;;;;+BAKAW,O,sBAAU;AACN,aAAKP,QAAL,CAAcM,aAAd,GAA8B,IAA9B;AACA,aAAKP,IAAL,CAAU,IAAV,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,KAAtB,EAA6B,IAA7B;AACAJ,yBAAiBa,KAAjB,CAAuBC,IAAvB,CAA4B,IAA5B;AACH,K;;AAED;;;;;;;;;+BAOAZ,M,mBAAOG,Q,EAAU;AACb,YAAIU,kBAAJ;AACA,YAAIV,SAASW,YAAT,IAAyB,KAAKT,GAAlC,EAAuC;;AAEnC;AACAF,qBAASW,YAAT,GAAwB,KAAKT,GAA7B;;AAEA,gBAAI,KAAKC,IAAT,EAAe;AACX;AACAH,yBAASY,eAAT;AACAZ,yBAASa,WAAT,CAAqB,KAAKZ,KAA1B;AACH,aAJD,MAIO;AACHD,yBAASc,IAAT;AACA,oBAAI,KAAKV,QAAT,EAAmB;AACfM,gCAAY,KAAKN,QAAjB;AACH;AACD,qBAAKU,IAAL,GALG,CAKU;AAChB;AACJ;AACD,eAAOJ,SAAP;AACH,K;;AAED;;;;;;+BAIAI,I,mBAAO;AACHC,aAAKC,OAAL,CAAaC,QAAb,CAAsBC,aAAtB,CAAoC,IAApC;AACH,K;;AAED;;;;;;;;AAsBA;;;;;;;;;;;qBAWOC,M,mBAAOnB,Q,EAAUC,K,EAAOC,G,EAAKC,I,EAAMC,Q,EAAU;AAChD,YAAIgB,QAAJ;AACA,YAAI,KAAKZ,KAAL,CAAWa,MAAf,EAAuB;AACnBD,uBAAW,KAAKZ,KAAL,CAAWc,GAAX,EAAX;AACH,SAFD,MAEO;AACHF,uBAAW,IAAIzB,gBAAJ,EAAX;AACH;AACDyB,iBAASrB,IAAT,CAAcC,QAAd,EAAwBC,KAAxB,EAA+BC,GAA/B,EAAoCC,IAApC,EAA0CC,QAA1C;AACA,eAAOgB,QAAP;AACH,K;;;;4BApCc;AACX,gBAAMG,WAAW,CAAC,KAAKvB,QAAL,CAAcW,YAAd,GAA6B,KAAKV,KAAnC,KAA6C,KAAKC,GAAL,GAAW,KAAKD,KAA7D,CAAjB;AACA,mBAAOuB,KAAKC,GAAL,CAAS,CAAT,EAAYD,KAAKE,GAAL,CAAS,CAAT,EAAYH,QAAZ,CAAZ,CAAP,CAFW,CAEgC;AAC9C;;AAED;;;;;;;;;;4BAOmB;AACf,mBAAO7B,IAAP;AACH;;;;;;AAyBLiC,OAAOC,OAAP,GAAiBjC,gBAAjB","file":"AnimatorTimeline.js","sourcesContent":["const pool = [];\n\n/**\n * Represents a single animation play.\n * @class AnimatorTimeline\n * @memberof PIXI.animate\n */\nclass AnimatorTimeline {\n    constructor() {\n        this._update = this.update.bind(this);\n        this.init(null, 0, 0, false, null);\n    }\n\n    /**\n     * The pool of timelines to use\n     * @method PIXI.animate.AnimatorTimeline#init\n     * @param {PIXI.animate.MovieClip} instance\n     * @param {Number} start\n     * @param {Number} end\n     * @param {Boolean} loop\n     * @param {Function} callback\n     * @private\n     */\n    init(instance, start, end, loop, callback) {\n\n        /**\n         * Instance of clip to play.\n         * @name PIXI.animate.AnimatorTimeline#instance\n         * @type {PIXI.animate.MovieClip}\n         * @readOnly\n         */\n        this.instance = instance;\n\n        /**\n         * `true` if the timeline is suppose to loop.\n         * @name PIXI.animate.AnimatorTimeline#loop\n         * @type {Boolean}\n         * @readOnly\n         */\n        this.loop = loop;\n\n        /**\n         * Frame number of the starting farme.\n         * @name PIXI.animate.AnimatorTimeline#start\n         * @type {int}\n         * @readOnly\n         */\n        this.start = start;\n\n        /**\n         * Frame number of the ending frame.\n         * @name PIXI.animate.AnimatorTimeline#end\n         * @type {int}\n         * @readOnly\n         */\n        this.end = end;\n\n        /**\n         * Callback called when completed (non-looping animation).\n         * @name PIXI.animate.AnimatorTimeline#callback\n         * @type {Function}\n         * @readOnly\n         */\n        this.callback = callback;\n\n        if (instance) {\n            instance.gotoAndStop(start);\n            instance._beforeUpdate = this._update;\n        }\n    }\n\n    /**\n     * Don't use after this\n     * @method PIXI.animate.AnimatorTimeline#destroy\n     * @private\n     */\n    destroy() {\n        this.instance._beforeUpdate = null;\n        this.init(null, 0, 0, false, null);\n        AnimatorTimeline._pool.push(this);\n    }\n\n    /**\n     * Is the animation complete\n     * @method PIXI.animate.AnimatorTimeline#update\n     * @param {PIXI.animate.MovieClip} instance\n     * @return {Function} Callback to do after updateTimeline\n     * @private\n     */\n    update(instance) {\n        let completed;\n        if (instance.currentFrame >= this.end) {\n\n            // In case we over-shoot the current frame becuase of low FPS\n            instance.currentFrame = this.end;\n\n            if (this.loop) {\n                // Update timeline so we get actions at the end frame\n                instance._updateTimeline();\n                instance.gotoAndPlay(this.start);\n            } else {\n                instance.stop();\n                if (this.callback) {\n                    completed = this.callback;\n                }\n                this.stop(); // cleanup timeline\n            }\n        }\n        return completed;\n    }\n\n    /**\n     * Stop the animation, cannot be reused.\n     * @method PIXI.animate.AnimatorTimeline#stop\n     */\n    stop() {\n        PIXI.animate.Animator._internalStop(this);\n    }\n\n    /**\n     * The progress from 0 to 1 of the playback.\n     * @name PIXI.animate.AnimatorTimeline#progress\n     * @type {Number}\n     * @readOnly\n     */\n    get progress() {\n        const progress = (this.instance.currentFrame - this.start) / (this.end - this.start);\n        return Math.max(0, Math.min(1, progress)); // clamp\n    }\n\n    /**\n     * The pool of timelines to use\n     * @name PIXI.animate.AnimatorTimeline._pool\n     * @type {Array<PIXI.animate.AnimatorTimeline>}\n     * @static\n     * @private\n     */\n    static get _pool() {\n        return pool;\n    }\n\n    /**\n     * Create a new timeline\n     * @method PIXI.animate.AnimatorTimeline.create\n     * @static\n     * @param {PIXI.animate.MovieClip} instance\n     * @param {Number} start\n     * @param {Number} end\n     * @param {Boolean} loop\n     * @param {Function} callback\n     * @return {PIXI.animate.AnimatorTimeline}\n     */\n    static create(instance, start, end, loop, callback) {\n        var timeline;\n        if (this._pool.length) {\n            timeline = this._pool.pop();\n        } else {\n            timeline = new AnimatorTimeline();\n        }\n        timeline.init(instance, start, end, loop, callback);\n        return timeline;\n    }\n}\n\nmodule.exports = AnimatorTimeline;"]}