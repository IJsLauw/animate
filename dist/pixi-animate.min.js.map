{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/animate/Animator.js","src/animate/AnimatorTimeline.js","src/animate/MovieClip.js","src/animate/Scene.js","src/animate/ShapesCache.js","src/animate/SymbolLoader.js","src/animate/Timeline.js","src/animate/Tween.js","src/animate/index.js","src/animate/load.js","src/animate/sound.js","src/animate/utils.js","src/mixins/Container.js","src/mixins/DisplayObject.js","src/mixins/Graphics.js","src/mixins/Sprite.js","src/mixins/Text.js","src/mixins/index.js","index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixiAnimate","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_AnimatorTimeline","timelines","Animator","play","instance","label","callback","loop","start","end","labelIsFunction","undefined","totalFrames","labelsMap","STOP_LABEL","LOOP_LABEL","fromTo","to","currentFrame","startLabel","endLabel","stop","timeline","_AnimatorTimeline2","default","create","_timelines","push","gotoAndPlay","len","_internalStop","stopAll","splice","indexOf","destroy","pool","AnimatorTimeline","_classCallCheck","_update","update","bind","init","gotoAndStop","_beforeUpdate","_pool","completed","_updateTimeline","PIXI","animate","pop","progress","Math","max","min","_Timeline","_utils","Container","SharedTicker","ticker","shared","MovieClip","options","duration","framerate","labels","_this","_possibleConstructorReturn","_Container","mode","INDEPENDENT","startPosition","Object","assign","_labels","_labelDict","name","position","sort","b","selfAdvance","paused","actionsEnabled","autoReset","_synchOffset","_prevPos","_t","_framerate","_duration","_totalFrames","_timedChildTimelines","_depthSorted","_actions","_tickListener","_onAdded","_onRemoved","on","advance","_setTimelinePosition","_goto","parentFramerate","add","tickerDeltaTime","seconds","speed","settings","TARGET_FPMS","remove","_autoExtend","endFrame","_parseProperties","properties","_utils2","hexToUint","v","_getChildTimeline","target","_Timeline2","addTimedMask","keyframes","addKeyframe","m","parseInt","am","addTween","startFrame","ease","at","addTimedChild","SYNCHED","parentStartPosition","fillFrames","deserializeKeyframes","lastFrame","_i","extendLastFrame","aa","addAction","index","actions","ps","alias","playSound","sound","emit","positionOrLabel","time","floor","afterUpdateOnce","pos","NaN","_reset","synched","SINGLE_FRAME","doActions","j","tween","setPosition","timedChildTimelines","depthSorted","shouldBeChild","parent","addChild","removeChild","_target","children","addChildAt","child","needsLoop","frameActions","destroyChildren","hiddenChildren","_currentProps","_i2","_timeline","_i3","prototype","current","value","fps","DEFAULT_FRAMERATE","extend","__parent","constructor","_load2","_sound","Scene","width","height","renderOptions","noWebGL","_PIXI$Application","_sound2","load","StageRef","complete","basePath","_this2","_load3","stage","removeView","Application","ShapesCache","defineProperty","enumerable","prop","items","deserializeShapes","item","arg","id","_typeof","_ShapesCache","SymbolLoader","resource","next","url","data","search","_ShapesCache2","nodeName","Texture","addTextureToCache","fromFrame","loaders","Loader","addPixiMiddleware","_Tween","Timeline","Array","p","startProps","hasOwnProperty","startValue","getPropFromShorthand","endProps","_Tween2","prevTween","isTweenlessFrame","x","y","scale","skew","rotation","alpha","visible","mask","lerpValue","lerpRotation","abs","PI","TWO_PI","setPropFromShorthand","transform","c","apply","ma","Tween","setToEnd","_prop","lerp","props","_prop2","sx","sy","kx","ky","_load","_MovieClip","_Scene","_SymbolLoader","_Animator","utils","VERSION","loader","metadata","done","assets","keys","_basePath","once","EventEmitter","_prepare","AnimateUtils","hex","substr","replace","oldLength","fill","result","keysMap","X","Y","A","B","C","D","R","L","T","F","V","buffer","isFrameStarted","frame","parseValue","str","shapes","split","isCommand","shape","test","parseFloat","forEach","val","upload","renderer","displayObject","plugins","prepare","register","addMovieClips","ac","DisplayObject","ColorMatrixFilter","filters","setRenderable","re","renderable","setTransform","setMask","Graphics","Sprite","console","warn","setAlpha","setTint","tint","setColorTransform","rA","gA","bA","filter","colorTransformFilter","matrix","set","_colorTransformFilter","get","drawCommands","d","commands","currentCommand","params","closePath","h","addHole","moveTo","lineTo","q","quadraticCurveTo","bezierCurveTo","beginFill","lineStyle","dr","drawRect","rr","drawRoundedRect","rc","dc","drawCircle","ar","arc","arcTo","de","drawEllipse","lf","colorArray","sd","bs","17","anchor","align","setStyle","ss","style","k","STYLE_PROPS","setShadow","sh","color","angle","distance","dropShadow","isUndefinedOr","defaultValue","18","__esModule","_Container2","_interopRequireDefault","_DisplayObject","_Graphics","_Graphics2","./Container","./DisplayObject","./Graphics","./Sprite","./Text","19","./animate","./mixins"],"mappings":"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","file":"pixi-animate.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import AnimatorTimeline from './AnimatorTimeline';\n\n// Static collection of timelines\nconst timelines = [];\n\n/**\n * Play animation via start/stop frame labels\n * @class Animator\n * @memberof PIXI.animate\n */\nclass Animator {\n\n    /**\n     * The collection of timelines\n     * @name {Array<PIXI.animate.AnimatorTimeline>} PIXI.animate.Animator#_timelines\n     * @private\n     * @static\n     */\n    static get _timelines() {\n        return timelines;\n    }\n\n    /**\n     * Suffix added to label for a stop.\n     * @name {String} PIXI.animate.Animator.STOP_LABEL\n     * @static\n     * @default \"_stop\"\n     */\n    static get STOP_LABEL() {\n        return \"_stop\";\n    }\n\n    /**\n     * Suffix added to label for a loop.\n     * @name {String} PIXI.animate.Animator.LOOP_LABEL\n     * @static\n     * @default \"_loop\"\n     */\n    static get LOOP_LABEL() {\n        return \"_loop\";\n    }\n\n    /**\n     * Play an animation by frame labels. For instance, play animation sequence from\n     * \"idle\" to \"idle_stop\" or \"idle_loop\". If no event label is provided, will\n     * play the entire duration of the MovieClip.\n     * @method PIXI.animate.Animator#play\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     * @param {String|Function} [label] The frame label event to call, if no event is provided\n     *        will use the entire length of the MovieClip. Can also be the callback.\n     * @param {Function} [callback] Optional callback when complete\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\n     */\n    static play(instance, label, callback) {\n        let loop = false;\n        let start, end;\n        const labelIsFunction = typeof label === \"function\";\n        if (label === undefined || labelIsFunction) {\n            start = 0;\n            end = instance.totalFrames - 1;\n            if (labelIsFunction) {\n                callback = label;\n            }\n        } else {\n            start = instance.labelsMap[label];\n            end = instance.labelsMap[label + this.STOP_LABEL];\n            if (end === undefined) {\n                end = instance.labelsMap[label + this.LOOP_LABEL];\n                loop = true;\n            }\n            if (start === undefined) {\n                throw new Error(\"No start label matching '\" + label + \"'\");\n            } else if (end === undefined) {\n                throw new Error(\"No end label matching '\" + label + \"'\");\n            }\n        }\n        return this.fromTo(\n            instance,\n            start,\n            end,\n            loop,\n            callback\n        );\n    }\n\n    /**\n     * Play an animation from the current frame to an end frame or label.\n     * @method PIXI.animate.Animator#to\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     * @param {String|Number} end The end frame or label.\n     * @param {Function} [callback] Optional callback when complete\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\n     */\n    static to(instance, end, callback) {\n        return this.fromTo(\n            instance,\n            instance.currentFrame,\n            end,\n            false,\n            callback\n        );\n    }\n\n    /**\n     * Play a MovieClip from a start to end frame.\n     * @method PIXI.animate.Animator#fromTo\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     * @param {Number|String} start The starting frame index or label.\n     * @param {Number|String} end The ending frame index or label.\n     * @param {Boolean} [loop=false] If the animation should loop.\n     * @param {Function} [callback] Optional callback when complete\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\n     */\n    static fromTo(instance, start, end, loop, callback) {\n\n        if (typeof start === \"string\") {\n            const startLabel = start;\n            start = instance.labelsMap[startLabel];\n            if (start === undefined) {\n                throw new Error(\"No start label matching '\" + startLabel + \"'\");\n            }\n        }\n        if (typeof end === \"string\") {\n            const endLabel = end;\n            end = instance.labelsMap[endLabel];\n            if (end === undefined) {\n                throw new Error(\"No end label matching '\" + endLabel + \"'\");\n            }\n        }\n        if (start < 0) {\n            throw new Error('Start frame is out of bounds');\n        }\n        if (end >= instance.totalFrames) {\n            throw new Error('End frame is out of bounds');\n        }\n        if (start >= end) {\n            throw new Error('End frame is before start frame');\n        }\n\n        // Stop any animation that's playing\n        this.stop(instance);\n\n        loop = !!loop;\n\n        // Add a new timeline\n        const timeline = AnimatorTimeline.create(\n            instance,\n            start,\n            end,\n            loop,\n            callback\n        );\n        this._timelines.push(timeline);\n\n        // Set the current frame\n        if (instance.currentFrame !== start) {\n            instance.gotoAndPlay(start);\n        } else {\n            instance.play();\n        }\n        return timeline;\n    }\n\n    /**\n     * Stop the animation by instance.\n     * @method PIXI.animate.Animator#stop\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     */\n    static stop(instance) {\n        for (let i = 0, len = this._timelines.length; i < len; i++) {\n            const timeline = this._timelines[i];\n            if (timeline.instance === instance) {\n                this._internalStop(timeline);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Stop all the currently playing animations.\n     * @method PIXI.animate.Animator#stopAll\n     * @static\n     */\n    static stopAll() {\n        for (let i = this._timelines.length - 1; i >= 0; i--) {\n            this._internalStop(this._timelines[i]);\n        }\n    }\n\n    /**\n     * Stop the animation\n     * @method PIXI.animate.Animator#_internalStop\n     * @private\n     * @static\n     * @param {PIXI.animate.AnimatorTimeline} timeline Timeline to stop.\n     */\n    static _internalStop(timeline) {\n        this._timelines.splice(this._timelines.indexOf(timeline), 1);\n        timeline.instance.stop();\n        timeline.destroy();\n    }\n}\n\nmodule.exports = Animator;","const pool = [];\n\n/**\n * Represents a single animation play.\n * @class AnimatorTimeline\n * @memberof PIXI.animate\n */\nclass AnimatorTimeline {\n    constructor() {\n        this._update = this.update.bind(this);\n        this.init(null, 0, 0, false, null);\n    }\n\n    /**\n     * The pool of timelines to use\n     * @method PIXI.animate.AnimatorTimeline#init\n     * @param {PIXI.animate.MovieClip} instance\n     * @param {Number} start\n     * @param {Number} end\n     * @param {Boolean} loop\n     * @param {Function} callback\n     * @private\n     */\n    init(instance, start, end, loop, callback) {\n\n        /**\n         * Instance of clip to play.\n         * @name PIXI.animate.AnimatorTimeline#instance\n         * @type {PIXI.animate.MovieClip}\n         * @readOnly\n         */\n        this.instance = instance;\n\n        /**\n         * `true` if the timeline is suppose to loop.\n         * @name PIXI.animate.AnimatorTimeline#loop\n         * @type {Boolean}\n         * @readOnly\n         */\n        this.loop = loop;\n\n        /**\n         * Frame number of the starting farme.\n         * @name PIXI.animate.AnimatorTimeline#start\n         * @type {int}\n         * @readOnly\n         */\n        this.start = start;\n\n        /**\n         * Frame number of the ending frame.\n         * @name PIXI.animate.AnimatorTimeline#end\n         * @type {int}\n         * @readOnly\n         */\n        this.end = end;\n\n        /**\n         * Callback called when completed (non-looping animation).\n         * @name PIXI.animate.AnimatorTimeline#callback\n         * @type {Function}\n         * @readOnly\n         */\n        this.callback = callback;\n\n        if (instance) {\n            instance.gotoAndStop(start);\n            instance._beforeUpdate = this._update;\n        }\n    }\n\n    /**\n     * Don't use after this\n     * @method PIXI.animate.AnimatorTimeline#destroy\n     * @private\n     */\n    destroy() {\n        this.instance._beforeUpdate = null;\n        this.init(null, 0, 0, false, null);\n        AnimatorTimeline._pool.push(this);\n    }\n\n    /**\n     * Is the animation complete\n     * @method PIXI.animate.AnimatorTimeline#update\n     * @param {PIXI.animate.MovieClip} instance\n     * @return {Function} Callback to do after updateTimeline\n     * @private\n     */\n    update(instance) {\n        let completed;\n        if (instance.currentFrame >= this.end) {\n\n            // In case we over-shoot the current frame becuase of low FPS\n            instance.currentFrame = this.end;\n\n            if (this.loop) {\n                // Update timeline so we get actions at the end frame\n                instance._updateTimeline();\n                instance.gotoAndPlay(this.start);\n            } else {\n                instance.stop();\n                if (this.callback) {\n                    completed = this.callback;\n                }\n                this.stop(); // cleanup timeline\n            }\n        }\n        return completed;\n    }\n\n    /**\n     * Stop the animation, cannot be reused.\n     * @method PIXI.animate.AnimatorTimeline#stop\n     */\n    stop() {\n        PIXI.animate.Animator._internalStop(this);\n    }\n\n    /**\n     * The progress from 0 to 1 of the playback.\n     * @name PIXI.animate.AnimatorTimeline#progress\n     * @type {Number}\n     * @readOnly\n     */\n    get progress() {\n        const progress = (this.instance.currentFrame - this.start) / (this.end - this.start);\n        return Math.max(0, Math.min(1, progress)); // clamp\n    }\n\n    /**\n     * The pool of timelines to use\n     * @name PIXI.animate.AnimatorTimeline._pool\n     * @type {Array<PIXI.animate.AnimatorTimeline>}\n     * @static\n     * @private\n     */\n    static get _pool() {\n        return pool;\n    }\n\n    /**\n     * Create a new timeline\n     * @method PIXI.animate.AnimatorTimeline.create\n     * @static\n     * @param {PIXI.animate.MovieClip} instance\n     * @param {Number} start\n     * @param {Number} end\n     * @param {Boolean} loop\n     * @param {Function} callback\n     * @return {PIXI.animate.AnimatorTimeline}\n     */\n    static create(instance, start, end, loop, callback) {\n        var timeline;\n        if (this._pool.length) {\n            timeline = this._pool.pop();\n        } else {\n            timeline = new AnimatorTimeline();\n        }\n        timeline.init(instance, start, end, loop, callback);\n        return timeline;\n    }\n}\n\nmodule.exports = AnimatorTimeline;","import Timeline from './Timeline';\nimport utils from './utils';\n\nconst Container = PIXI.Container;\nconst SharedTicker = PIXI.ticker.shared;\n\n/**\n * Provide timeline playback of movieclip\n * @memberof PIXI.animate\n * @class MovieClip\n * @extends PIXI.Container\n * @constructor\n * @param {Object|int} [options] The options object or the mode to play\n * @param {int} [options.mode=0] The playback mode default is independent (0),\n * @param {int} [options.startPosition=0] The starting frame\n * @param {Boolean} [options.loop=true] If playback is looped\n * @param {Object} [options.labels] The frame labels map of label to frames\n * @param {int} [options.duration] The duration, if no duration is provided, auto determines length\n * @param {int} [options.framerate=24] The framerate to use for independent mode\n */\nclass MovieClip extends Container {\n    constructor(options, duration, loop, framerate, labels) {\n        super();\n\n        // Default options\n        options = options === undefined ? {} : options;\n\n        // Options can also be the mode\n        if (typeof options === 'number') {\n            options = {\n                mode: options || MovieClip.INDEPENDENT,\n                duration: duration || 0,\n                loop: loop === undefined ? true : loop,\n                labels: labels || {},\n                framerate: framerate || 0,\n                startPosition: 0\n            };\n        } else {\n            // Apply defaults to options\n            options = Object.assign({\n                mode: MovieClip.INDEPENDENT,\n                startPosition: 0,\n                loop: true,\n                labels: {},\n                duration: 0,\n                framerate: 0\n            }, options);\n        }\n\n        /**\n         * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).\n         * See each constant for a description of the behaviour.\n         * @name PIXI.animate.MovieClip#mode\n         * @type int\n         * @default null\n         */\n        this.mode = options.mode;\n\n        /**\n         * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.\n         * @name PIXI.animate.MovieClip#startPosition\n         * @type Number\n         * @default 0\n         */\n        this.startPosition = options.startPosition;\n\n        /**\n         * Indicates whether this MovieClip should loop when it reaches the end of its timeline.\n         * @name PIXI.animate.MovieClip#loop\n         * @type Boolean\n         * @default true\n         */\n        this.loop = !!options.loop;\n\n        /**\n         * The current frame of the movieclip.\n         * @name PIXI.animate.MovieClip#currentFrame\n         * @type Number\n         * @default 0\n         * @readOnly\n         */\n        this.currentFrame = 0;\n\n        /**\n         * The collection of private labels\n         * @name PIXI.animate.MovieClip#_labels\n         * @type Array\n         * @private\n         */\n        this._labels = [];\n\n        /**\n         * The collection of private labels\n         * @name PIXI.animate.MovieClip#_labelDict\n         * @type Object\n         * @private\n         */\n        this._labelDict = options.labels;\n        if (options.labels) {\n            for (let name in options.labels) {\n                let label = {\n                    label: name,\n                    position: options.labels[name]\n                };\n                this._labels.push(label);\n            }\n            this._labels.sort(function(a, b) {\n                return a.position - b.position;\n            });\n        }\n\n        /**\n         * If true, this movieclip will animate automatically whenever it is on the stage.\n         * @name PIXI.animate.MovieClip#selfAdvance\n         * @type Boolean\n         * @default true\n         */\n        this.selfAdvance = true;\n\n        /**\n         * If true, the MovieClip's position will not advance when ticked.\n         * @name PIXI.animate.MovieClip#paused\n         * @type Boolean\n         * @default false\n         */\n        this.paused = false;\n\n        /**\n         * If true, actions in this MovieClip's tweens will be run when the playhead advances.\n         * @name PIXI.animate.MovieClip#actionsEnabled\n         * @type Boolean\n         * @default true\n         */\n        this.actionsEnabled = true;\n\n        /**\n         * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds\n         * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.\n         * <br><br>\n         * For example, if you had a character animation with a 'body' child MovieClip instance\n         * with different costumes on each frame, you could set body.autoReset = false, so that\n         * you can manually change the frame it is on, without worrying that it will be reset\n         * automatically.\n         * @name PIXI.animate.MovieClip#autoReset\n         * @type Boolean\n         * @default true\n         */\n        this.autoReset = true;\n\n        /**\n         * @name PIXI.animate.MovieClip#_synchOffset\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._synchOffset = 0;\n\n        /**\n         * @name PIXI.animate.MovieClip#_prevPos\n         * @type Number\n         * @default -1\n         * @private\n         */\n        this._prevPos = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.\n\n        /**\n         * Note - changed from default: When the MovieClip is framerate independent, this is the time\n         * elapsed from frame 0 in seconds.\n         * @name PIXI.animate.MovieClip#_t\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._t = 0;\n\n        /**\n         * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n         * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n         * framerate.\n         *\n         * @name PIXI.animate.MovieClip#_framerate\n         * @type {Number}\n         * @default 0\n         * @protected\n         */\n        this._framerate = options.framerate;\n\n        /**\n         * The total time in seconds for the animation. This is changed when setting the framerate.\n         * @name PIXI.animate.MovieClip#_duration\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._duration = 0;\n\n        /**\n         * The total duration in frames for the animation.\n         * @name PIXI.animate.MovieClip#_totalFrames\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._totalFrames = options.duration;\n\n        /**\n         * Standard tween timelines for all objects. Each element in the _timelines array\n         * is a Timeline object - an array of tweens for one target, in order of occurrence.\n         * @name PIXI.animate.MovieClip#_timelines\n         * @type Array\n         * @protected\n         */\n        this._timelines = [];\n\n        /**\n         * Array of child timelines denoting if a child is actively a child of this movieclip\n         * on any given frame. Each element in the _timedChildTimelines is an array with a 'target'\n         * property, and is an array of boolean values indexed by frame.\n         * @name PIXI.animate.MovieClip#_timedChildTimelines\n         * @type {Array}\n         * @protected\n         */\n        this._timedChildTimelines = [];\n\n        /**\n         * Array to depth sort timed children\n         * @name PIXI.animate.MovieClip#_depthSorted\n         * @type {Array}\n         * @private\n         */\n        this._depthSorted = [];\n\n        /**\n         * Array of frame scripts, indexed by frame.\n         * @name PIXI.animate.MovieClip#_actions\n         * @type {Array}\n         * @protected\n         */\n        this._actions = [];\n\n        /**\n         * Optional callback fired before timeline is updated.\n         * Can be used to clamp or update the currentFrame.\n         * @name PIXI.animate.MovieClip#_beforeUpdate\n         * @type {Function}\n         * @private\n         */\n        this._beforeUpdate = null;\n\n        if (this.mode === MovieClip.INDEPENDENT) {\n            this._tickListener = this._tickListener.bind(this);\n            this._onAdded = this._onAdded.bind(this);\n            this._onRemoved = this._onRemoved.bind(this);\n            this.on('added', this._onAdded);\n            this.on('removed', this._onRemoved);\n        }\n\n        if (options.framerate) {\n            this.framerate = options.framerate;\n        }\n\n        //save often used methods on the instance so that they can be fetched slightly faster\n        //than if they had to be fetched from the prototype\n        this.advance = this.advance;\n        this._updateTimeline = this._updateTimeline;\n        this._setTimelinePosition = this._setTimelinePosition;\n        this._goto = this._goto;\n    }\n\n    _onAdded() {\n        if (!this._framerate) {\n            this.framerate = this.parentFramerate;\n        }\n        SharedTicker.add(this._tickListener);\n    }\n\n    _tickListener(tickerDeltaTime) {\n        if (this.paused || !this.selfAdvance) {\n            //see if the movieclip needs to be updated even though it isn't animating\n            if (this._prevPos < 0) {\n                this._goto(this.currentFrame);\n            }\n            return;\n        }\n        let seconds = tickerDeltaTime / SharedTicker.speed / PIXI.settings.TARGET_FPMS / 1000;\n        this.advance(seconds);\n    }\n\n    _onRemoved() {\n        SharedTicker.remove(this._tickListener);\n    }\n\n    /**\n     * Returns an array of objects with label and position (aka frame) properties, sorted by position.\n     * @name PIXI.animate.MovieClip#labels\n     * @type {Array}\n     * @readonly\n     */\n    get labels() {\n        return this._labels;\n    }\n\n    /**\n     * Returns a dictionary of labels where key is the label and value is the frame.\n     * @name PIXI.animate.MovieClip#labelsMap\n     * @type {Object}\n     * @readonly\n     */\n    get labelsMap() {\n        return this._labelDict;\n    }\n\n    /**\n     * Returns the name of the label on or immediately before the current frame.\n     * @name PIXI.animate.MovieClip#currentLabel\n     * @type {String}\n     * @readonly\n     */\n    get currentLabel() {\n        let labels = this._labels;\n        let current = null;\n        for (let i = 0, len = labels.length; i < len; ++i) {\n            if (labels[i].position <= this.currentFrame) {\n                current = labels[i].label;\n            } else {\n                break;\n            }\n        }\n        return current;\n    }\n\n    /**\n     * When the MovieClip is framerate independent, this is the time elapsed from frame 0 in seconds.\n     * @name PIXI.animate.MovieClip#elapsedTime\n     * @type Number\n     * @default 0\n     * @public\n     */\n    get elapsedTime() {\n        return this._t;\n    }\n\n    set elapsedTime(value) {\n        this._t = value;\n    }\n\n    /**\n     * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n     * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n     * framerate.\n     *\n     * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will\n     * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n     * vary slightly between frames.\n     *\n     * This feature is dependent on the tick event object (or an object with an appropriate 'delta' property) being\n     * passed into {{#crossLink 'Stage/update'}}{{/crossLink}}.\n     * @name PIXI.animate.MovieClip#framerate\n     * @type {Number}\n     * @default 0\n     */\n    get framerate() {\n        return this._framerate;\n    }\n    set framerate(value) {\n        if (value > 0) {\n            this._framerate = value;\n            this._duration = value ? this._totalFrames / value : 0;\n            this._t = this.currentFrame / value;\n        } else {\n            this._t = this._framerate = this._duration = 0;\n        }\n    }\n\n    /**\n     * Get the total number of frames (duration) of this MovieClip\n     * @name PIXI.animate.MovieClip#totalFrames\n     * @type {Number}\n     * @default 0\n     * @readOnly\n     */\n    get totalFrames() {\n        return this._totalFrames;\n    }\n\n    /**\n     * Extend the timeline to the last frame.\n     * @method PIXI.animate.MovieClip#_autoExtend\n     * @private\n     * @param {int} endFrame\n     */\n    _autoExtend(endFrame) {\n        if (this._totalFrames < endFrame) {\n            this._totalFrames = endFrame;\n        }\n    }\n\n    /**\n     * Convert values of properties\n     * @method PIXI.animate.MovieClip#_parseProperties\n     * @private\n     * @param {Object} properties\n     */\n    _parseProperties(properties) {\n        // Convert any string colors to uints\n        if (typeof properties.t === 'string') {\n            properties.t = utils.hexToUint(properties.t);\n        } else if (typeof properties.v === 'number') {\n            properties.v = !!properties.v;\n        }\n    }\n\n    /**\n     * Get a timeline for a child, synced timeline.\n     * @method PIXI.animate.MovieClip#_getChildTimeline\n     * @private\n     * @param {PIXI.animate.MovieClip} instance\n     * @return {PIXI.animate.Timeline}\n     */\n    _getChildTimeline(instance) {\n        for (let i = this._timelines.length - 1; i >= 0; --i) {\n            if (this._timelines[i].target === instance) {\n                return this._timelines[i];\n            }\n        }\n        let timeline = new Timeline(instance);\n        this._timelines.push(timeline);\n        return timeline;\n    }\n\n    /**\n     * Add mask or masks\n     * @method PIXI.animate.MovieClip#addTimedMask\n     * @param {PIXI.DisplayObject} instance Instance to mask\n     * @param {Object} keyframes The map of frames to mask objects\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\n     */\n    addTimedMask(instance, keyframes) {\n        for (let i in keyframes) {\n            this.addKeyframe(instance, {\n                m: keyframes[i]\n            }, parseInt(i, 10));\n        }\n\n        // Set the initial position/add\n        this._setTimelinePosition(this.currentFrame, this.currentFrame, true);\n        return this;\n    }\n\n    /**\n     * Shortcut alias for `addTimedMask`\n     * @method PIXI.animate.MovieClip#am\n     * @param {PIXI.DisplayObject} instance Instance to mask\n     * @param {Object} keyframes The map of frames to mask objects\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\n     */\n    am(instance, keyframes) {\n        return this.addTimedMask(instance, keyframes);\n    }\n\n    /**\n     * Add a tween to the clip\n     * @method PIXI.animate.MovieClip#addTween\n     * @param {PIXI.DisplayObject} instance The clip to tween\n     * @param {Object} properties The property or property to tween\n     * @param {int} startFrame The frame to start tweening\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\n     *                           with no tweening.\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\n     * @return {PIXI.animate.MovieClip}\n     */\n    addTween(instance, properties, startFrame, duration, ease) {\n\n        let timeline = this._getChildTimeline(instance);\n        this._parseProperties(properties);\n        timeline.addTween(properties, startFrame, duration, ease);\n        this._autoExtend(startFrame + duration);\n        return this;\n    }\n\n    /**\n     * Add a tween to the clip\n     * @method PIXI.animate.MovieClip#addKeyframe\n     * @param {PIXI.DisplayObject} instance The clip to tween\n     * @param {Object} properties The property or property to tween\n     * @param {int} startFrame The frame to start tweening\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\n     *                           with no tweening.\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\n     * @return {PIXI.animate.MovieClip}\n     */\n    addKeyframe(instance, properties, startFrame) {\n\n        let timeline = this._getChildTimeline(instance);\n        this._parseProperties(properties);\n        timeline.addKeyframe(properties, startFrame);\n        this._autoExtend(startFrame);\n        return this;\n    }\n\n    /**\n     * Alias for method `addTimedChild`\n     * @method PIXI.animate.MovieClip#at\n     * @return {PIXI.animate.MovieClip}\n     */\n    at(instance, startFrame, duration, keyframes) {\n        return this.addTimedChild(instance, startFrame, duration, keyframes);\n    }\n\n    /**\n     * Add a child to show for a certain number of frames before automatic removal.\n     * @method PIXI.animate.MovieClip#addTimedChild\n     * @param {PIXI.DisplayObject} instance The clip to show\n     * @param {int} startFrame The starting frame\n     * @param {int} [duration=1] The number of frames to display the child before removing it.\n     * @param {String|Array} [keyframes] The collection of static keyframes to add\n     * @return {PIXI.animate.MovieClip}\n     */\n    addTimedChild(instance, startFrame, duration, keyframes) {\n\n        if (startFrame === undefined) // jshint ignore:line\n        {\n            startFrame = 0;\n        }\n        if (duration === undefined || duration < 1) // jshint ignore:line\n        {\n            duration = this._totalFrames || 1;\n        }\n\n        // Add the starting offset for synced movie clips\n        if (instance.mode === MovieClip.SYNCHED) {\n            instance.parentStartPosition = startFrame;\n        }\n\n        //add tweening info about this child's presence on stage\n        //when the child is (re)added, if it has 'autoReset' set to true, then it\n        //should be set back to frame 0\n        let timeline, i;\n        //get existing timeline\n        for (i = this._timedChildTimelines.length - 1; i >= 0; --i) {\n            if (this._timedChildTimelines[i].target === instance) {\n                timeline = this._timedChildTimelines[i];\n                break;\n            }\n        }\n        //if there wasn't one, make a new one\n        if (!timeline) {\n            timeline = [];\n            timeline.target = instance;\n            this._timedChildTimelines.push(timeline);\n        }\n\n        // Fill the timeline with keyframe booleans\n        utils.fillFrames(timeline, startFrame, duration);\n\n        // Update the total frames if the instance extends our current\n        // total frames for this movieclip\n        if (this._totalFrames < startFrame + duration) {\n            this._totalFrames = startFrame + duration;\n        }\n\n        // Add the collection of keyframes\n        if (keyframes) {\n            if (typeof keyframes === \"string\") {\n                keyframes = utils.deserializeKeyframes(keyframes);\n            }\n            // Convert the keyframes object into\n            // individual properties\n            let lastFrame = {};\n            for (let i in keyframes) {\n                lastFrame = Object.assign({}, lastFrame, keyframes[i]);\n                this.addKeyframe(instance, lastFrame, parseInt(i, 10));\n            }\n            this._getChildTimeline(instance)\n                .extendLastFrame(startFrame + duration);\n        }\n\n        // Set the initial position/add\n        this._setTimelinePosition(startFrame, this.currentFrame, true);\n\n        return this;\n    }\n\n    /**\n     * Short cut for `addAction`\n     * @method PIXI.animate.MovieClip#aa\n     * @param {Function} callback The clip call on a certain frame\n     * @param {int|String} startFrame The starting frame index or label\n     * @return {PIXI.animate.MovieClip}\n     */\n    aa(callback, startFrame) {\n        return this.addAction(callback, startFrame);\n    }\n\n    /**\n     * Handle frame actions, callback is bound to the instance of the MovieClip.\n     * @method PIXI.animate.MovieClip#addAction\n     * @param {Function} callback The clip call on a certain frame\n     * @param {int|String} startFrame The starting frame index or label\n     * @return {PIXI.animate.MovieClip}\n     */\n    addAction(callback, startFrame) {\n\n        if (typeof startFrame === 'string') {\n            const index = this._labelDict[startFrame];\n            if (index === undefined) {\n                throw `The label '${startFrame}' does not exist on this timeline`;\n            }\n            startFrame = index;\n        }\n\n        let actions = this._actions;\n        //ensure that the movieclip timeline is long enough to support the target frame\n        if (actions.length <= startFrame) {\n            actions.length = startFrame + 1;\n        }\n        if (this._totalFrames < startFrame) {\n            this._totalFrames = startFrame;\n        }\n        //add the action\n        if (actions[startFrame]) {\n            actions[startFrame].push(callback);\n        } else {\n            actions[startFrame] = [callback];\n        }\n        return this;\n    }\n\n    /**\n     * Short cut for `playSound`\n     * @method PIXI.animate.MovieClip#ps\n     * @param {String} alias The name of the Sound\n     * @param {Boolean} [loop=false] The loop property of the sound\n     * @param {MovieClip} context The MovieClip the sound originates from\n     * @return {PIXI.animate.MovieClip}\n     */\n    ps(alias, loop) {\n        return this.playSound(alias, loop);\n    }\n\n    /**\n     * Handle sounds.\n     * @method PIXI.animate.MovieClip#playSound\n     * @param {String} alias The name of the Sound\n     * @param {Boolean} [loop=false] The loop property of the sound\n     * @param {MovieClip} context The MovieClip the sound originates from\n     * @return {PIXI.animate.MovieClip}\n     */\n    playSound(alias, loop) {\n        PIXI.animate.sound.emit('play', alias, !!loop, this);\n        return this;\n    }\n\n    /**\n     * Sets paused to false.\n     * @method PIXI.animate.MovieClip#play\n     */\n    play() {\n        this.paused = false;\n    }\n\n    /**\n     * Sets paused to true.\n     * @method PIXI.animate.MovieClip#stop\n     */\n    stop() {\n        this.paused = true;\n    }\n\n    /**\n     * Advances this movie clip to the specified position or label and sets paused to false.\n     * @method PIXI.animate.MovieClip#gotoAndPlay\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n     */\n    gotoAndPlay(positionOrLabel) {\n        this.paused = false;\n        this._goto(positionOrLabel);\n    }\n\n    /**\n     * Advances this movie clip to the specified position or label and sets paused to true.\n     * @method PIXI.animate.MovieClip#gotoAndStop\n     * @param {String|Number} positionOrLabel The animation or frame name to go to.\n     */\n    gotoAndStop(positionOrLabel) {\n        this.paused = true;\n        this._goto(positionOrLabel);\n    }\n\n    /**\n     * Get the close parent with a valid framerate. If no parent, returns the default framerate.\n     * @name PIXI.animate.MovieClip#parentFramerate\n     * @type {Number}\n     * @readOnly\n     */\n    get parentFramerate() {\n        let o = this,\n            fps = o._framerate;\n        while ((o = o.parent) && !fps) {\n            if (o.mode === MovieClip.INDEPENDENT) {\n                fps = o._framerate;\n            }\n        }\n        return fps || MovieClip.DEFAULT_FRAMERATE;\n    }\n\n    /**\n     * Advances the playhead. This occurs automatically each tick by default.\n     * @method PIXI.animate.MovieClip#advance\n     * @param [time] {Number} The amount of time in seconds to advance by. Only applicable if framerate is set.\n     */\n    advance(time) {\n\n        // Handle any other cases where starting to play\n        // and no framerate has been set yet\n        if (!this._framerate) {\n            this.framerate = this.parentFramerate;\n        }\n\n        if (time) {\n            this._t += time;\n        }\n        if (this._t > this._duration) {\n            this._t = this.loop ? this._t - this._duration : this._duration;\n        }\n        //add a tiny amount to account for potential floating point errors\n        this.currentFrame = Math.floor(this._t * this._framerate + 0.00000001);\n        //final error checking\n        if (this.currentFrame >= this._totalFrames) {\n            this.currentFrame = this._totalFrames - 1;\n        }\n        let afterUpdateOnce;\n        if (this._beforeUpdate) {\n            afterUpdateOnce = this._beforeUpdate(this);\n        }\n        //update all tweens & actions in the timeline\n        this._updateTimeline();\n\n        // Do the animator callback here\n        if (afterUpdateOnce) {\n            afterUpdateOnce();\n        }\n    }\n\n    /**\n     * @method PIXI.animate.MovieClip#_goto\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n     * @protected\n     */\n    _goto(positionOrLabel) {\n        let pos = typeof positionOrLabel === 'string' ? this._labelDict[positionOrLabel] : positionOrLabel;\n        if (pos === undefined) // jshint ignore:line\n        {\n            return;\n        }\n        // prevent _updateTimeline from overwriting the new position because of a reset:\n        this._prevPos = NaN;\n        this.currentFrame = pos;\n\n        // Handle the case where trying to play but haven't\n        // added to the stage yet\n        if (!this._framerate) {\n            this.framerate = this.parentFramerate;\n        }\n\n        //update the elapsed time if a time based movieclip\n        if (this._framerate > 0) {\n            this._t = pos / this._framerate;\n        } else {\n            this._t = 0;\n        }\n        this._updateTimeline();\n    }\n\n    /**\n     * @method PIXI.animate.MovieClip#_reset\n     * @private\n     */\n    _reset() {\n        this._prevPos = -1;\n        this._t = 0;\n        this.currentFrame = 0;\n    }\n\n    /**\n     * @method PIXI.animate.MovieClip#_updateTimeline\n     * @protected\n     */\n    _updateTimeline() {\n        let synched = this.mode !== MovieClip.INDEPENDENT;\n\n        if (synched) {\n            this.currentFrame = this.startPosition + (this.mode === MovieClip.SINGLE_FRAME ? 0 : this._synchOffset);\n            if (this.currentFrame >= this._totalFrames) {\n                this.currentFrame %= this._totalFrames;\n            }\n        }\n\n        if (this._prevPos === this.currentFrame) {\n            return;\n        }\n\n        // update timeline position, ignoring actions if this is a graphic.\n        this._setTimelinePosition(this._prevPos, this.currentFrame, synched ? false : this.actionsEnabled);\n\n        this._prevPos = this.currentFrame;\n    }\n\n    /**\n     * Set the timeline position\n     * @method PIXI.animate.MovieClip#_setTimelinePosition\n     * @protected\n     * @param {int} startFrame\n     * @param {int} currentFrame\n     * @param {Boolean} doActions\n     */\n    _setTimelinePosition(startFrame, currentFrame, doActions) {\n        //handle all tweens\n        let i, j, length, _timelines = this._timelines;\n        for (i = _timelines.length - 1; i >= 0; --i) {\n            let timeline = _timelines[i];\n            for (j = 0, length = timeline.length; j < length; ++j) {\n                let tween = timeline[j];\n                //if the tween contains part of the timeline that we are travelling through\n                if (currentFrame >= tween.startFrame &&\n                    currentFrame <= tween.endFrame) {\n                    // set the position within that tween\n                    //and break the loop to move onto the next timeline\n                    tween.setPosition(currentFrame);\n                    break;\n                }\n            }\n        }\n\n        let timedChildTimelines = this._timedChildTimelines;\n        let depthSorted = this._depthSorted;\n        for (i = 0, length = timedChildTimelines.length; i < length; ++i) {\n            let target = timedChildTimelines[i].target;\n            let shouldBeChild = timedChildTimelines[i][currentFrame];\n            //if child should be on stage and is not:\n            if (shouldBeChild) {\n                // Add to the depthSorted object so we can\n                // check that items are property drawn later\n                depthSorted.push(target);\n                if (target.parent !== this) {\n                    // add the target if it's not there already\n                    this.addChild(target);\n                    if (target.mode === MovieClip.INDEPENDENT && target.autoReset) {\n                        target._reset();\n                    }\n                }\n            } else if (!shouldBeChild && target.parent === this) {\n                this.removeChild(target);\n            }\n        }\n\n        // Properly depth sort the children\n        for (i = 0, length = depthSorted.length; i < length; i++) {\n            let target = depthSorted[i];\n            let currentIndex = this.children.indexOf(target);\n            if (currentIndex !== i) {\n                this.addChildAt(target, i);\n            }\n        }\n\n        // Clear the temporary depth sorting array\n        depthSorted.length = 0;\n\n        //go through all children and update synched movieclips that are not single frames\n        let children = this.children,\n            child;\n        for (i = 0, length = children.length; i < length; ++i) {\n            child = children[i];\n            if (child.mode === MovieClip.SYNCHED) {\n                child._synchOffset = currentFrame - child.parentStartPosition;\n                child._updateTimeline();\n            }\n        }\n\n        //handle actions\n        if (doActions) {\n            let actions = this._actions;\n            //handle looping around\n            let needsLoop = false;\n            if (currentFrame < startFrame) {\n                length = actions.length;\n                needsLoop = true;\n            } else {\n                length = Math.min(currentFrame + 1, actions.length);\n            }\n            for (i = startFrame >= 0 ? startFrame + 1 : currentFrame; i < length; ++i) {\n                if (actions[i]) {\n                    let frameActions = actions[i];\n                    for (j = 0; j < frameActions.length; ++j) {\n                        frameActions[j].call(this);\n                    }\n                }\n                //handle looping around\n                if (needsLoop && i === length - 1) {\n                    i = 0;\n                    length = currentFrame + 1;\n                    needsLoop = false;\n                }\n            }\n        }\n    }\n\n    destroy(destroyChildren) {\n        if (this._tickListener) {\n            SharedTicker.remove(this._tickListener);\n            this._tickListener = null;\n        }\n        const hiddenChildren = [];\n        let timelines = this._timelines;\n        if (timelines) {\n            for (let i = 0; i < timelines.length; i++) {\n                const timeline = timelines[i];\n                hiddenChildren.push(timeline.target);\n                timeline._currentProps = null;\n                timeline.length = 0;\n            }\n        }\n        timelines = this._timedChildTimelines;\n        if (timelines) {\n            for (let i = 0; i < timelines.length; i++) {\n                const timeline = timelines[i];\n                if (hiddenChildren.indexOf(timeline.target) < 0) {\n                    hiddenChildren.push(timeline.target);\n                }\n                timeline._currentProps = null;\n                timeline.length = 0;\n            }\n        }\n        // Destroy all the children\n        for (let i = 0; i < hiddenChildren.length; i++) {\n            // Don't destroy children in the display list\n            if (this.children.indexOf(hiddenChildren[i]) < 0) {\n                hiddenChildren[i].destroy(destroyChildren);\n            }\n        }\n        hiddenChildren.length = 0;\n        this._actions = null;\n        this._timelines = null;\n        this._depthSorted = null;\n        this._timedChildTimelines = null;\n        this._beforeUpdate = null;\n        this._labels = null;\n        this._labelDict = null;\n        super.destroy(destroyChildren);\n    }\n}\n\n/**\n * The MovieClip will advance independently of its parent, even if its parent is paused.\n * This is the default mode.\n * @name PIXI.animate.MovieClip.INDEPENDENT\n * @static\n * @type String\n * @default 0\n * @readonly\n */\nMovieClip.INDEPENDENT = 0;\n\n/**\n * The MovieClip will only display a single frame (as determined by the startPosition property).\n * @name PIXI.animate.MovieClip.SINGLE_FRAME\n * @static\n * @type String\n * @default 1\n * @readonly\n */\nMovieClip.SINGLE_FRAME = 1;\n\n/**\n * The MovieClip will be advanced only when its parent advances and will be synched to the position of\n * the parent MovieClip.\n * @name PIXI.animate.MovieClip.SYNCHED\n * @static\n * @type String\n * @default 2\n * @readonly\n */\nMovieClip.SYNCHED = 2;\n\n\n/**\n * The default framerate if none is specified or there's not parent clip with a framerate.\n * @name PIXI.animate.MovieClip.DEFAULT_FRAMERATE\n * @static\n * @type Number\n * @default 24\n * @readonly\n */\nMovieClip.DEFAULT_FRAMERATE = 24;\n\n/**\n * Extend a container\n * @method PIXI.animate.MovieClip.extend\n * @static\n * @param {PIXI.animate.MovieClip} child The child function\n * @return {PIXI.animate.MovieClip} The child\n */\n/**\n * Extend a container (alias for `extend`)\n * @method PIXI.animate.MovieClip.e\n * @static\n * @param {PIXI.animate.MovieClip} child The child function\n * @return {PIXI.animate.MovieClip} The child\n */\nMovieClip.extend = MovieClip.e = function(child) {\n    child.prototype = Object.create(MovieClip.prototype);\n    child.prototype.__parent = MovieClip.prototype;\n    child.prototype.constructor = child;\n    return child;\n};\n\n// Assign to namespace\nexport default MovieClip;","import load from './load';\nimport sound from './sound';\n\n/**\n * Extends the PIXI.Application class to provide easy loading.\n * ```\n * const scene = new PIXI.animate.Scene();\n * scene.load(lib.StageName);\n * ```\n * @class Scene\n * @memberof PIXI.animate\n * @param {Number} [width=800] Stage width\n * @param {Number} [height=600] Stage height\n * @param {Object} [renderOptions] See PIXI.Application for more info.\n * @param {Boolean} [noWebGL=false] Disable WebGL\n */\nclass Scene extends PIXI.Application {\n\n\tconstructor(width, height, renderOptions, noWebGL) {\n\t\tsuper(width, height, renderOptions, noWebGL);\n\n\t\t/**\n\t\t * Reference to the global sound object\n\t\t * @name PIXI.animate.Scene#sound\n\t\t * @type {PIXI.animate.sound}\n\t\t * @readOnly\n\t\t */\n\t\tthis.sound = sound;\n\n\t\t/**\n\t\t * The stage object created.\n\t\t * @name PIXI.animate.Scene#instance\n\t\t * @type {PIXI.animate.MovieClip}\n\t\t * @readOnly\n\t\t */\n\t\tthis.instance = null;\n\t}\n\n\t/**\n\t * Load a stage scene and add it to the stage.\n\t * @method PIXI.animate.Scene#load\n\t * @param {Function} StageRef Reference to the stage class.\n\t * @param {Function} [complete] Callback when finished loading.\n\t * @param {String} [basePath] Optional base directory to prepend to assets.\n\t * @return {PIXI.loaders.Loader} instance of PIXI resource loader\n\t */\n\tload(StageRef, complete, basePath) {\n\t\treturn load(StageRef, this.stage, (instance) => {\n\t\t\tthis.instance = instance;\n\t\t\tif (complete) {\n\t\t\t\tcomplete(instance);\n\t\t\t}\n\t\t}, basePath);\n\t}\n\n\t/**\n\t * Destroy and don't use after calling.\n\t * @method PIXI.animate.Scene#destroy\n\t * @param {Boolean} [removeView=false] `true` to remove canvas element.\n\t */\n\tdestroy(removeView) {\n\t\tif (this.instance) {\n\t\t\tthis.instance.destroy(true);\n\t\t\tthis.instance = null;\n\t\t}\n\t\tsuper.destroy(removeView);\n\t}\n}\n\nexport default Scene;","import utils from './utils';\n\n/**\n * Contains the collection of graphics data\n * @memberof PIXI.animate\n * @class ShapesCache\n */\nconst ShapesCache = {};\n\n/**\n * Add an item or itesm to the cache\n * @method PIXI.animate.ShapesCache.add\n * @static\n * @param {String} prop  The id of graphic or the map of graphics to add\n * @param {String|Array<Array>} items Collection of draw commands\n */\nObject.defineProperty(ShapesCache, 'add', {\n    enumerable: false,\n    value: function(prop, items) {\n\n        // Decode string to map of files\n        if (typeof items === \"string\") {\n            items = utils.deserializeShapes(items);\n        }\n\n        // Convert all hex string colors (animate) to int (pixi.js)\n        for (let i = 0; i < items.length; i++) {\n            let item = items[i];\n            for (let j = 0; j < item.length; j++) {\n                let arg = item[j];\n                if (typeof arg === 'string' && arg[0] === '#') {\n                    item[j] = utils.hexToUint(arg);\n                }\n            }\n        }\n        ShapesCache[prop] = items;\n    }\n});\n\n\n/**\n * Get the graphic from cache\n * @method  PIXI.animate.ShapesCache.fromCache\n * @static\n * @param  {String} id The cache id\n * @return {Array} Series of graphic draw commands\n */\nObject.defineProperty(ShapesCache, 'fromCache', {\n    enumerable: false,\n    value: function(id) {\n        return ShapesCache[id] || null;\n    }\n});\n\n/**\n * Remove the graphic from cache\n * @method  PIXI.animate.ShapesCache.remove\n * @static\n * @param  {String|Object} id The cache id or map\n */\nObject.defineProperty(ShapesCache, 'remove', {\n    enumerable: false,\n    value: function(id) {\n        if (typeof id === \"object\") {\n            for (let name in id) {\n                ShapesCache.remove(name);\n            }\n            return;\n        }\n        if (ShapesCache[id]) {\n            ShapesCache[id].length = 0;\n            delete ShapesCache[id];\n        }\n    }\n});\n\n/**\n * Remove all graphics from cache\n * @method  PIXI.animate.ShapesCache.removeAll\n * @static\n */\nObject.defineProperty(ShapesCache, 'removeAll', {\n    enumerable: false,\n    value: function() {\n        for (let id in ShapesCache) {\n            ShapesCache.remove(id);\n        }\n    }\n});\n\n// Assign to namespace\nexport default ShapesCache;","import ShapesCache from './ShapesCache';\n\n/**\n * The middleware for PIXI's ResourceLoader to be able to \n * load Flash symbols such as graphics and images.\n * @memberof PIXI.animate\n * @class SymbolLoader\n * @private\n */\nlet SymbolLoader = function() {\n    return function(resource, next) {\n        let url = resource.url;\n        let data = resource.data;\n\n        if (!data) {\n            next();\n        } else if (url.search(/\\.shapes\\.(json|txt)$/i) > -1) {\n            ShapesCache.add(resource.name, data);\n        } else if (data.nodeName && data.nodeName === 'IMG') {\n            // Add individual images to the texture cache by their\n            // short symbol name, not the URL\n            PIXI.Texture.addTextureToCache(\n                PIXI.Texture.fromFrame(url),\n                resource.name\n            );\n        }\n        next();\n    };\n};\n\n// Assign to the loader\nPIXI.loaders.Loader.addPixiMiddleware(SymbolLoader);\n\nexport default SymbolLoader;","import Tween from './Tween';\n\n/**\n * The Timeline class represents a\n * @memberof PIXI.animate\n * @class Timeline\n * @param {PIXI.DisplayObject} Target The target for this string of tweens.\n * @extends Array\n * @constructor\n */\nconst Timeline = function(target) {\n    Array.call(this);\n\n    /**\n     * The target DisplayObject.\n     * @name PIXI.animate.Timeline#target\n     * @type {PIXI.DisplayObject}\n     */\n    this.target = target;\n\n    /**\n     * Current properties in the tween, to make building the timeline more\n     * efficient.\n     * @name PIXI.animate.Timeline#_currentProps\n     * @type {Object}\n     * @private\n     */\n    this._currentProps = {};\n};\n\nconst p = Timeline.prototype = Object.create(Array.prototype);\n\n/**\n * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the normal ticking system)\n * and managed by this timeline. Adding a tween to multiple timelines will result in unexpected behaviour.\n * @method PIXI.animate.Timeline#addTween\n * @param tween The tween(s) to add. Accepts multiple arguments.\n * @return Tween The first tween that was passed in.\n */\np.addTween = function(properties, startFrame, duration, ease) {\n    this.extendLastFrame(startFrame - 1);\n    //ownership of startProps is passed to the new Tween - this object should not be reused\n    let startProps = {};\n    let prop;\n    //figure out what the starting values for this tween should be\n    for (prop in properties) {\n        //if we have already set that property in an earlier tween, use the ending value\n        if (this._currentProps.hasOwnProperty(prop)) {\n            startProps[prop] = this._currentProps[prop];\n        }\n        //otherwise, get the current value\n        else {\n            let startValue = startProps[prop] = this.getPropFromShorthand(prop);\n            //go through previous tweens to set the value so that when the timeline loops\n            //around, the values are set properly - having each tween know what came before\n            //allows us to set to a specific frame without running through the entire timeline\n            for (let i = this.length - 1; i >= 0; --i) {\n                this[i].startProps[prop] = startValue;\n                this[i].endProps[prop] = startValue;\n            }\n        }\n    }\n    //create the new Tween and add it to the list\n    let tween = new Tween(this.target, startProps, properties, startFrame, duration, ease);\n    this.push(tween);\n    //update starting values for the next tween - if tweened values included 'p', then Tween\n    //parsed that to add additional data that is required\n    Object.assign(this._currentProps, tween.endProps);\n};\n\n/**\n * Add a single keyframe that doesn't tween.\n * @method PIXI.animate.Timeline#addKeyframe\n * @param {Object} properties The properties to set.\n * @param {int} startFrame The starting frame index.\n */\np.addKeyframe = function(properties, startFrame) {\n    this.extendLastFrame(startFrame - 1);\n    let startProps = Object.assign({}, this._currentProps, properties);\n    //create the new Tween and add it to the list\n    let tween = new Tween(this.target, startProps, null, startFrame, 0);\n    this.push(tween);\n    Object.assign(this._currentProps, tween.endProps);\n};\n\n/**\n * Extend the last frame of the tween.\n * @method PIXI.animate.Timeline#extendLastFrame\n * @param {int} endFrame The ending frame index.\n */\np.extendLastFrame = function(endFrame) {\n    if (this.length) {\n        let prevTween = this[this.length - 1];\n        if (prevTween.endFrame < endFrame) {\n            if (prevTween.isTweenlessFrame) {\n                prevTween.endFrame = endFrame;\n            } else {\n                this.addKeyframe(\n                    this._currentProps,\n                    prevTween.endFrame + 1,\n                    endFrame - prevTween.endFrame + 1\n                );\n            }\n        }\n    }\n};\n\n/**\n * Get the value for a property\n * @method PIXI.animate.Timeline#getPropFromShorthand\n * @param {string} prop\n */\np.getPropFromShorthand = function(prop) {\n    const target = this.target;\n    switch (prop) {\n        case 'x':\n            return target.position.x;\n        case 'y':\n            return target.position.y;\n        case 'sx':\n            return target.scale.x;\n        case 'sy':\n            return target.scale.y;\n        case 'kx':\n            return target.skew.x;\n        case 'ky':\n            return target.skew.y;\n        case 'r':\n            return target.rotation;\n        case 'a':\n            return target.alpha;\n        case 'v':\n            return target.visible;\n        case 'm':\n            return target.mask;\n            // case 't':\n            //   return target.tint;\n            //not sure if we'll actually handle graphics this way?\n            //g: return null;\n    }\n    return null;\n};\n\n// Assign to namespace\nexport default Timeline;","/**\n * Provide timeline playback of movieclip\n * @memberof PIXI.animate\n * @class Tween\n * @constructor\n * @param {PIXI.animate.MovieClip} target The target to play\n * @param {Object} startProps The starting properties\n * @param {Object} endProps The ending properties\n * @param {int} duration Number oframes to tween\n * @param {Function} [ease] Ease function to use\n */\n\nclass Tween {\n\n    constructor(target, startProps, endProps, startFrame, duration, ease) {\n\n        /**\n         * target display object\n         * @name PIXI.animate.Tween#target\n         * @type {Object}\n         */\n        this.target = target;\n\n        /**\n         * properties at the start of the tween\n         * @type {Object}\n         * @name PIXI.animate.Tween#startProps\n         */\n        this.startProps = startProps;\n\n        /**\n         * properties at the end of the tween, as well as any properties that are set\n         * instead of tweened\n         * @type {Object}\n         * @name PIXI.animate.Tween#endProps\n         */\n        this.endProps = {};\n\n        /**\n         * duration of tween in frames. For a keyframe with no tweening, the duration will be 0.\n         * @type {int}\n         * @name PIXI.animate.Tween#duration\n         */\n        this.duration = duration;\n\n        /**\n         * The frame that the tween starts on\n         * @type {int}\n         * @name PIXI.animate.Tween#startFrame\n         */\n        this.startFrame = startFrame;\n\n        /**\n         * the frame that the tween ends on\n         * @type {int}\n         * @name PIXI.animate.Tween#endFrame\n         */\n        this.endFrame = startFrame + duration;\n\n        /**\n         * easing function to use, if any\n         * @type {Function}\n         * @name PIXI.animate.Tween#ease\n         */\n        this.ease = ease;\n\n        /**\n         * If we don't tween.\n         * @type {Boolean}\n         * @name PIXI.animate.Tween#isTweenlessFrame\n         */\n        this.isTweenlessFrame = !endProps;\n\n\n        let prop;\n        if (endProps) {\n            //make a copy to safely include any unchanged values from the start of the tween\n            for (prop in endProps) {\n                this.endProps[prop] = endProps[prop];\n            }\n        }\n\n        //copy in any starting properties don't change\n        for (prop in startProps) {\n            if (!this.endProps.hasOwnProperty(prop)) {\n                this.endProps[prop] = startProps[prop];\n            }\n        }\n    }\n\n    /**\n     * Set the current frame.\n     * @method PIXI.animate.Tween#setPosition\n     * @param {int} currentFrame\n     */\n    setPosition(currentFrame) {\n        //if this is a single frame with no tweening, or at the end of the tween, then\n        //just speed up the process by setting values\n        if (currentFrame >= this.endFrame) {\n            this.setToEnd();\n            return;\n        }\n\n        if (this.isTweenlessFrame) {\n            this.setToEnd();\n            return;\n        }\n\n        let time = (currentFrame - this.startFrame) / this.duration;\n        if (this.ease) {\n            time = this.ease(time);\n        }\n        let target = this.target;\n        let startProps = this.startProps;\n        let endProps = this.endProps;\n        for (let prop in endProps) {\n            let lerp = props[prop];\n            if (lerp) {\n                setPropFromShorthand(target, prop, lerp(startProps[prop], endProps[prop], time));\n            } else {\n                setPropFromShorthand(target, prop, startProps[prop]);\n            }\n        }\n    }\n\n    /**\n     * Set to the end position\n     * @method PIXI.animate.Tween#setToEnd\n     */\n    setToEnd() {\n        let endProps = this.endProps;\n        let target = this.target;\n        for (let prop in endProps) {\n            setPropFromShorthand(target, prop, endProps[prop]);\n        }\n    }\n}\n\n//standard tweening\nfunction lerpValue(start, end, t) {\n    return start + (end - start) * t;\n}\n\nconst props = {\n    //position\n    x: lerpValue,\n    y: lerpValue,\n    //scale\n    sx: lerpValue,\n    sy: lerpValue,\n    //skew\n    kx: lerpValue,\n    ky: lerpValue,\n    //rotation\n    r: lerpRotation,\n    //alpha\n    a: lerpValue,\n    //tinting\n    // t: lerpColor,\n    t: null,\n    //values to be set\n    v: null, //visible\n    c: null, //colorTransform\n    m: null, //mask\n    g: null //not sure if we'll actually handle graphics this way?\n};\n\n//split r, g, b into separate values for tweening\n/*function lerpColor(start, end, t)\n{\n    //split start color into components\n    let sR = start >> 16 & 0xFF;\n    let sG = start >> 8 & 0xFF;\n    let sB = start & 0xFF;\n    //split end color into components\n    let eR = end >> 16 & 0xFF;\n    let eG = end >> 8 & 0xFF;\n    let eB = end & 0xFF;\n    //lerp red\n    let r = sR + (eR - sR) * percent;\n    //clamp red to valid values\n    if (r < 0)\n        r = 0;\n    else if (r > 255)\n        r = 255;\n    //lerp green\n    let g = sG + (eG - sG) * percent;\n    //clamp green to valid values\n    if (g < 0)\n        g = 0;\n    else if (g > 255)\n        g = 255;\n    //lerp blue\n    let b = sB + (eB - sB) * percent;\n    //clamp blue to valid values\n    if (b < 0)\n        b = 0;\n    else if (b > 255)\n        b = 255;\n\n    let combined = (r << 16) | (g << 8) | b;\n    return combined;\n}*/\n\nconst PI = Math.PI;\nconst TWO_PI = PI * 2;\n\n//handle 355 -> 5 degrees only going through a 10 degree change instead of\n//the long way around\n//Math from http://stackoverflow.com/a/2708740\nfunction lerpRotation(start, end, t) {\n    let difference = Math.abs(end - start);\n    if (difference > PI) {\n        // We need to add on to one of the values.\n        if (end > start) {\n            // We'll add it on to start...\n            start += TWO_PI;\n        } else {\n            // Add it on to end.\n            end += PI + TWO_PI;\n        }\n    }\n\n    // Interpolate it.\n    let value = (start + ((end - start) * t));\n\n    // wrap to 0-2PI\n    /*if (value >= 0 && value <= TWO_PI)\n        return value;\n    return value % TWO_PI;*/\n\n    //just return, as it's faster\n    return value;\n}\n\nfunction setPropFromShorthand(target, prop, value) {\n    switch (prop) {\n        case \"x\":\n            target.transform.position.x = value;\n            break;\n        case \"y\":\n            target.transform.position.y = value;\n            break;\n        case \"sx\":\n            target.transform.scale.x = value;\n            break;\n        case \"sy\":\n            target.transform.scale.y = value;\n            break;\n        case \"kx\":\n            target.transform.skew.x = value;\n            break;\n        case \"ky\":\n            target.transform.skew.y = value;\n            break;\n        case \"r\":\n            target.transform.rotation = value;\n            break;\n        case \"a\":\n            target.alpha = value;\n            break;\n        case \"t\":\n            target.i(value); // i = setTint\n            break;\n        case \"c\":\n            target.c.apply(target, value); // c = setColorTransform\n            break;\n        case \"v\":\n            target.visible = value;\n            break;\n        case \"m\":\n            target.ma(value); // ma = setMask\n            break;\n    }\n}\n\n// Assign to namespace\nexport default Tween;","import load from './load';\nimport sound from './sound';\nimport utils from './utils';\nimport MovieClip from './MovieClip';\nimport Scene from './Scene';\nimport ShapesCache from './ShapesCache';\nimport SymbolLoader from './SymbolLoader';\nimport Timeline from './Timeline';\nimport Tween from './Tween';\nimport Animator from './Animator';\nimport AnimatorTimeline from './AnimatorTimeline';\n\nconst VERSION = __VERSION__;\n\n/**\n * @namespace PIXI.animate\n */\nexport {\n    Animator,\n    AnimatorTimeline,\n    load,\n    sound,\n    utils,\n    MovieClip,\n    Scene,\n    ShapesCache,\n    SymbolLoader,\n    Timeline,\n    Tween,\n    VERSION\n};","/**\n * Load the stage class and preload any assets\n * @method PIXI.animate.load\n * @param {Object} options Options for loading.\n * @param {Function} options.stage Reference to the stage class\n * @param {Object} [options.stage.assets] Assets used to preload\n * @param {PIXI.Container} options.parent The Container to auto-add the stage to.\n * @param {String} [options.basePath] Base root directory\n * @return {PIXI.loaders.Loader} instance of PIXI resource loader\n */\n/**\n * Load the stage class and preload any assets\n * ```\n * let renderer = new PIXI.autoDetectRenderer(1280, 720);\n * let stage = new PIXI.Container();\n * PIXI.animate.load(lib.MyStage, function(instance){\n *     stage.addChild(instance);\n * });\n * function update() {\n *      renderer.render(stage);\n *      update();\n * }\n * update();\n * ```\n * @method PIXI.animate.load\n * @param {Function} StageRef Reference to the stage class.\n * @param {Object} [StageRef.assets] Assets used to preload.\n * @param {Function} complete The callback function when complete.\n * @return {PIXI.loaders.Loader} instance of PIXI resource loader\n */\n/**\n * Load the stage class and preload any assets\n * ```\n * let renderer = new PIXI.autoDetectRenderer(1280, 720);\n * let stage = new PIXI.Container();\n * PIXI.animate.load(lib.MyStage, stage);\n * function update() {\n *      renderer.render(stage);\n *      update();\n * }\n * update();\n * ```\n * @method PIXI.animate.load\n * @param {Function} StageRef Reference to the stage class.\n * @param {Object} [StageRef.assets] Assets used to preload.\n * @param {PIXI.Container} parent The Container to auto-add the stage to.\n * @param {String} [basePath] Base root directory\n * @return {PIXI.loaders.Loader} instance of PIXI resource loader\n */\n/**\n * Load the stage class and preload any assets\n * ```\n * let basePath = \"file:/path/to/assets\";\n * let renderer = new PIXI.autoDetectRenderer(1280, 720);\n * \n * let extensions = PIXI.compressedTextures.detectExtensions(renderer);\n * let loader = new PIXI.loaders.Loader();\n * // this is an example of setting up a pre loader plugin to handle compressed textures in this case\n * loader.pre(PIXI.compressedTextures.extensionChooser(extensions));\n * \n * // specify metadata this way if you want to provide a default loading strategy for all assets listed in the PIXI animation\n * let metadata = { default: { metadata: { imageMetadata: { choice: [\".crn\"] } } } };\n * // specify metadata this way if you want to provide a specific loading strategy for a certain asset listed inside the PIXI animation library\n * let metadata = { MyStage_atlas_1: { metadata: { imageMetadata: { choice: [\".crn\"] } } } };\n * \n * let stage = new PIXI.Container();\n * PIXI.animate.load(lib.MyStage, stage, ()=>{}, basePath, loader, metadata);\n * function update() {\n *      renderer.render(stage);\n *      update();\n * }\n * update();\n * ```\n * @method PIXI.animate.load\n * @param {Function} StageRef Reference to the stage class.\n * @param {Object} [StageRef.assets] Assets used to preload.\n * @param {PIXI.Container} parent The Container to auto-add the stage to.\n * @param {Function} [complete] The callback function when complete.\n * @param {String} [basePath] Base root directory\n * @param {PIXI.loaders.Loader} [loader] A Pixi loader object\n * @param {Object} [metadata] A metadata object for the asset being loaded\n * @return {PIXI.loaders.Loader} instance of PIXI resource loader\n */\n\nconst load = function(options, parent, complete, basePath, loader, metadata) {\n\n    // Support arguments (ref, complete, basePath)\n    if (typeof parent === \"function\") {\n        basePath = complete;\n        complete = parent;\n        parent = null;\n    } else {\n        if (typeof complete === \"string\") {\n            basePath = complete;\n            complete = null;\n        }\n    }\n\n    if (typeof options === \"function\") {\n        options = {\n            stage: options,\n            parent: parent,\n            basePath: basePath || \"\",\n            complete: complete\n        };\n    }\n\n    options = Object.assign({\n        stage: null,\n        parent: null,\n        basePath: '',\n        complete: null\n    }, options || {});\n\n    loader = loader ? loader : new PIXI.loaders.Loader();\n\n    function done() {\n        let instance = new options.stage();\n        if (options.parent) {\n            options.parent.addChild(instance);\n        }\n        if (options.complete) {\n            options.complete(instance, loader);\n        }\n    }\n\n    // Check for assets to preload\n    let assets = options.stage.assets || {};\n    if (assets && Object.keys(assets).length) {\n        // assetBaseDir can accept either with trailing slash or not\n        let basePath = options.basePath;\n        if (basePath) {\n            basePath += \"/\";\n        }\n        for (let id in assets) {\n            var data = null;\n            if(metadata) {\n                // if the metadata was supplied for this particular asset, use these options\n                if(metadata[id]) {\n                    data = metadata[id];\n                }\n                // if the metadata supplied a default option\n                else if (metadata.default){\n                    data = metadata.default;\n                }\n            }\n            loader.add(id, basePath + assets[id], data);\n        }\n        loader.once('complete', done).load();\n    } else {\n        // tiny case where there's only text and no shapes/animations\n        done();\n    }\n\n    return loader;\n};\n\nexport default load;\n","/**\n * @description Event emitter for all sound events. This emits a single\n * `play` event which contains the alias, loop and MovieClip which is playing\n * the sound.\n * @name PIXI.animate.sound\n * @type {EventEmitter}\n * @example\n * \n * PIXI.animate.sound.on('play', (alias, loop, context) => {\n *    // custom handle sounds being played\n *    // where 'alias' is the ID in stage assets\n * });\n */\nexport default new PIXI.utils.EventEmitter();","// If the movieclip plugin is installed\nlet _prepare = null;\n\n/**\n * @namespace PIXI.animate.utils\n * @description For keyframe conversions\n */\nexport default class AnimateUtils {\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     * @static\n     * @method PIXI.animate.utils.hexToUint\n     */\n    static hexToUint(hex) {\n        // Remove the hash\n        hex = hex.substr(1);\n\n        // Convert shortcolors fc9 to ffcc99\n        if (hex.length === 3) {\n            hex = hex.replace(/([a-f0-9])/g, '$1$1');\n        }\n        return parseInt(hex, 16);\n    }\n\n    /** \n     * Fill frames with booleans of true (showing) and false (hidden).\n     * @static\n     * @method PIXI.animate.utils.fillFrames\n     * @param {Array<Boolean>} timeline\n     * @param {int} startFrame The start frame when the timeline shows up\n     * @param {int} duration The length of showing\n     */\n    static fillFrames(timeline, startFrame, duration) {\n        //ensure that the timeline is long enough\n        const oldLength = timeline.length;\n        if (oldLength < startFrame + duration) {\n            timeline.length = startFrame + duration;\n            //fill any gaps with false to denote that the child should be removed for a bit\n            if (oldLength < startFrame) {\n                //if the browser has implemented the ES6 fill() function, use that\n                if (timeline.fill) {\n                    timeline.fill(false, oldLength, startFrame);\n                } else {\n                    //if we can't use fill, then do a for loop to fill it\n                    for (let i = oldLength; i < startFrame; ++i) {\n                        timeline[i] = false;\n                    }\n                }\n            }\n        }\n        //if the browser has implemented the ES6 fill() function, use that\n        if (timeline.fill) {\n            timeline.fill(true, startFrame, startFrame + duration);\n        } else {\n            const length = timeline.length;\n            //if we can't use fill, then do a for loop to fill it\n            for (let i = startFrame; i < length; ++i) {\n                timeline[i] = true;\n            }\n        }\n    }\n\n    /**\n     * Convert serialized array into keyframes\n     * `\"0x100y100 1x150\"` to: `{ \"0\": {\"x\":100, \"y\": 100}, \"1\": {\"x\": 150} }`\n     * @static\n     * @method PIXI.animate.utils.deserializeKeyframes\n     * @param {String} keyframes\n     * @param {Object} Resulting keyframes\n     */\n    static deserializeKeyframes(keyframes) {\n        let result = {};\n        let i = 0;\n        let keysMap = {\n            X: 'x', // x position\n            Y: 'y', // y position\n            A: 'sx', // scale x\n            B: 'sy', // scale y\n            C: 'kx', // skew x\n            D: 'ky', // skew y\n            R: 'r', // rotation\n            L: 'a', // alpha\n            T: 't', // tint\n            F: 'c', // colorTransform\n            V: 'v' // visibility\n        };\n        let c,\n            buffer = '',\n            isFrameStarted = false,\n            prop,\n            frame = {};\n\n        while (i <= keyframes.length) {\n            c = keyframes[i];\n            if (keysMap[c]) {\n                if (!isFrameStarted) {\n                    isFrameStarted = true;\n                    result[buffer] = frame;\n                }\n                if (prop) {\n                    frame[prop] = this.parseValue(prop, buffer);\n                }\n                prop = keysMap[c];\n                buffer = '';\n                i++;\n            }\n            // Start a new prop\n            else if (!c || c === ' ') {\n                i++;\n                frame[prop] = this.parseValue(prop, buffer);\n                buffer = '';\n                prop = null;\n                frame = {};\n                isFrameStarted = false;\n            } else {\n                buffer += c;\n                i++;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Convert serialized shapes into draw commands for PIXI.Graphics.\n     * @static\n     * @method PIXI.animate.utils.deserializeShapes\n     * @param {String} str\n     * @param {Array} Resulting shapes map\n     */\n    static deserializeShapes(str) {\n        const result = [];\n        // each shape is a new line\n        let shapes = str.split(\"\\n\");\n        let isCommand = /^[a-z]{1,2}$/;\n        for (let i = 0; i < shapes.length; i++) {\n            let shape = shapes[i].split(' '); // arguments are space separated\n            for (let j = 0; j < shape.length; j++) {\n                // Convert all numbers to floats, ignore colors\n                let arg = shape[j];\n                if (arg[0] !== '#' && !isCommand.test(arg)) {\n                    shape[j] = parseFloat(arg);\n                }\n            }\n            result.push(shape);\n        }\n        return result;\n    }\n\n    /** \n     * Parse the value of the compressed keyframe.\n     * @method PIXI.animate.utils.parseValue\n     * @static\n     * @private\n     * @param {String} prop The property key\n     * @param {String} buffer The contents\n     * @return {*} The parsed value\n     */\n    static parseValue(prop, buffer) {\n        switch (prop) {\n            // Color transforms are parsed as an array\n            case 'c':\n                {\n                    buffer = buffer.split(',');\n                    buffer.forEach(function(val, i, buffer) {\n                        buffer[i] = parseFloat(val);\n                    });\n                    return buffer;\n                }\n                // Tint value should not be converted\n                // can be color uint or string\n            case 't':\n                {\n                    return buffer;\n                }\n                // The visiblity parse as boolean\n            case 'v':\n                {\n                    return !!parseInt(buffer);\n                }\n                // Everything else parse a floats\n            default:\n                {\n                    return parseFloat(buffer);\n                }\n        }\n    }\n\n    /** \n     * Upload all the textures and graphics to the GPU. \n     * @method PIXI.animate.utils.upload\n     * @static\n     * @param {PIXI.WebGLRenderer} renderer Render to upload to\n     * @param {PIXI.DisplayObject} clip MovieClip to upload\n     * @param {function} done When complete\n     */\n    static upload(renderer, displayObject, done) {\n        if (!_prepare) {\n            _prepare = renderer.plugins.prepare;\n            _prepare.register(this.addMovieClips);\n        }\n        _prepare.upload(displayObject, done);\n    }\n\n    /**\n     * Add movie clips to the upload prepare.\n     * @method PIXI.animate.utils.addMovieClips\n     * @static\n     * @private\n     * @param {*} item To add to the queue \n     */\n    static addMovieClips(item) {\n        if (item instanceof PIXI.animate.MovieClip) {\n            item._timedChildTimelines.forEach((timeline) => {\n                const index = item.children.indexOf(timeline.target);\n                if (index === -1) {\n                    _prepare.add(timeline.target);\n                }\n            });\n            return true;\n        }\n        return false;\n    }\n}","/**\n * Mixins for the PIXI.Container class.\n * @class Container\n * @memberof PIXI\n */\nconst p = PIXI.Container.prototype;\n\n/**\n * Shortcut for `addChild`.\n * @method PIXI.Container#ac\n * @param {*} [child*] N-number of children\n * @return {PIXI.DisplayObject} Instance of first child added\n */\np.ac = p.addChild;\n\n/**\n * Extend a container\n * @method PIXI.Container.extend\n * @static\n * @param {PIXI.Container} child The child function\n * @return {PIXI.Container} THe child\n */\n/**\n * Extend a container (shortcut for `extend`)\n * @method PIXI.Container.e\n * @static\n * @param {PIXI.Container} child The child function\n * @return {PIXI.Container} THe child\n */\nPIXI.Container.extend = PIXI.Container.e = function(child) {\n    child.prototype = Object.create(p);\n    child.prototype.__parent = p;\n    child.prototype.constructor = child;\n    return child;\n};","import utils from '../animate/utils';\n\n/**\n * Mixins for the PIXI.DisplayObject class.\n * @memberof PIXI\n * @class DisplayObject\n */\nconst p = PIXI.DisplayObject.prototype;\n\n// Color Matrix filter\nlet ColorMatrixFilter;\nif (PIXI.filters) {\n    ColorMatrixFilter = PIXI.filters.ColorMatrixFilter;\n}\n\n/**\n * Function to see if this is renderable or not. Useful for setting masks.\n * @method PIXI.DisplayObject#setRenderable\n * @param  {Boolean} [renderable=false] Make renderable\n * @return {PIXI.DisplayObject}\n */\n/**\n * Shortcut to `setRenderable`.\n * @method PIXI.DisplayObject#re\n * @param  {Boolean} [renderable=false] Make renderable\n * @return {PIXI.DisplayObject}\n */\np.setRenderable = p.re = function(renderable) {\n    this.renderable = !!renderable;\n    return this;\n};\n\n/**\n * Shortcut for `setTransform`.\n * @method PIXI.DisplayObject#tr\n * @param {Number} x The X position\n * @param {Number} y The Y position\n * @param {Number} scaleX The X Scale value\n * @param {Number} scaleY The Y Scale value\n * @param {Number} skewX The X skew value\n * @param {Number} skewY The Y skew value\n * @param {Number} pivotX The X pivot value\n * @param {Number} pivotY The Y pivot value\n * @return {PIXI.DisplayObject} Instance for chaining\n */\np.t = p.setTransform;\n\n/**\n * Setter for mask to be able to chain.\n * @method PIXI.DisplayObject#setMask\n * @param {PIXI.Graphics} mask The mask shape to use\n * @return {PIXI.DisplayObject} Instance for chaining\n */\n/**\n * Shortcut for `setMask`.\n * @method PIXI.DisplayObject#ma\n * @param {PIXI.Sprite|PIXI.Graphics} mask The mask shape to use\n * @return {PIXI.DisplayObject} Instance for chaining\n */\np.setMask = p.ma = function(mask) {\n    // According to PIXI, only Graphics and Sprites can \n    // be used as mask, let's ignore everything else, like other\n    // movieclips and displayobjects/containers\n    if (mask) {\n        if (!(mask instanceof PIXI.Graphics) && !(mask instanceof PIXI.Sprite)) {\n            if (typeof console !== \"undefined\" && console.warn) {\n                console.warn(\"Warning: Masks can only be PIXI.Graphics or PIXI.Sprite objects.\");\n            }\n            return this;\n        }\n    }\n    this.mask = mask;\n    return this;\n};\n\n/**\n * Setter for the alpha\n * @method PIXI.DisplayObject#setAlpha\n * @param {Number} alpha The alpha amount to use, from 0 to 1\n * @return {PIXI.DisplayObject} Instance for chaining\n */\n/**\n * Shortcut for `setAlpha`.\n * @method PIXI.DisplayObject#a\n * @param {Number} alpha The alpha amount to use, from 0 to 1\n * @return {PIXI.DisplayObject} Instance for chaining\n */\np.setAlpha = p.a = function(alpha) {\n    this.alpha = alpha;\n    return this;\n};\n\n/**\n * Set the tint values by color.\n * @method PIXI.DisplayObject#setTint\n * @param {int} tint The color value to tint\n * @return {PIXI.DisplayObject} Object for chaining\n */\n/**\n * Shortcut to `setTint`.\n * @method PIXI.DisplayObject#tn\n * @param {Number|String} tint The red percentage value\n * @return {PIXI.DisplayObject} Object for chaining\n */\np.setTint = p.i = function(tint) {\n    if (typeof tint === \"string\") {\n        tint = utils.hexToUint(tint);\n    }\n    // this.tint = tint\n    // return this;\n    // TODO: Replace with DisplayObject.tint setter\n    // once the functionality is added to Pixi.js, for\n    // now we'll use the slower ColorMatrixFilter to handle\n    // the color transformation\n    var r = tint >> 16 & 0xFF;\n    var g = tint >> 8 & 0xFF;\n    var b = tint & 0xFF;\n    return this.c(r / 255, 0, g / 255, 0, b / 255, 0);\n};\n\n/**\n * Set additive and multiply color, tinting\n * @method PIXI.DisplayObject#setColorTransform\n * @param {Number} r The multiply red value\n * @param {Number} rA The additive red value\n * @param {Number} g The multiply green value\n * @param {Number} gA The additive green value\n * @param {Number} b The multiply blue value\n * @param {Number} bA The additive blue value\n * @return {PIXI.DisplayObject} Object for chaining\n */\n/**\n * Shortcut to `setColor`.\n * @method PIXI.DisplayObject#c\n * @param {Number} r The multiply red value\n * @param {Number} rA The additive red value\n * @param {Number} g The multiply green value\n * @param {Number} gA The additive green value\n * @param {Number} b The multiply blue value\n * @param {Number} bA The additive blue value\n * @return {PIXI.DisplayObject} Object for chaining\n */\np.setColorTransform = p.c = function(r, rA, g, gA, b, bA) {\n    var filter = this.colorTransformFilter;\n    filter.matrix[0] = r;\n    filter.matrix[4] = rA;\n    filter.matrix[6] = g;\n    filter.matrix[9] = gA;\n    filter.matrix[12] = b;\n    filter.matrix[14] = bA;\n    this.filters = [filter];\n    return this;\n};\n\n/**\n * The current default color transforming filters\n * @name {PIXI.filters.ColorMatrixFilter} PIXI.DisplayObject#colorTransformFilter\n */\nif (!p.hasOwnProperty('colorTransformFilter')) {\n    Object.defineProperty(p, 'colorTransformFilter', {\n        set: function(filter) {\n            this._colorTransformFilter = filter;\n        },\n        get: function() {\n            return this._colorTransformFilter || new ColorMatrixFilter();\n        }\n    });\n}\n\n/**\n * Extend a container\n * @method PIXI.DisplayObject.extend\n * @static\n * @param {PIXI.DisplayObject} child The child function\n * @return {PIXI.DisplayObject} THe child\n */\n/**\n * Extend a container (shortcut for `extend`)\n * @method PIXI.DisplayObject.e\n * @static\n * @param {PIXI.DisplayObject} child The child function\n * @return {PIXI.DisplayObject} THe child\n */\nPIXI.DisplayObject.extend = PIXI.DisplayObject.e = function(child) {\n    child.prototype = Object.create(p);\n    child.prototype.__parent = p;\n    child.prototype.constructor = child;\n    return child;\n};","/**\n * Mixins for the PIXI.Graphics class.\n * @memberof PIXI\n * @class Graphics\n */\nconst p = PIXI.Graphics.prototype;\n\n/**\n * Shortcut for `drawCommands`.\n * @method PIXI.Graphics#d\n * @param  {Array} commands The commands and parameters to draw\n * @return {PIXI.Graphics}\n */\n/**\n * Execute a series of commands, this is the name of the short function\n * followed by the parameters, e.g., `[\"f\", \"#ff0000\", \"r\", 0, 0, 100, 200]`\n * @method PIXI.Graphics#drawCommands\n * @param  {Array} commands The commands and parameters to draw\n * @return {PIXI.Graphics}\n */\np.drawCommands = p.d = function(commands) {\n    var currentCommand, params = [],\n        i = 0;\n\n    while (i <= commands.length) {\n        var item = commands[i++];\n        if (item === undefined || this[item]) {\n            if (currentCommand) {\n                this[currentCommand].apply(this, params);\n                params.length = 0;\n            }\n            currentCommand = item;\n        } else {\n            params.push(item);\n        }\n    }\n    return this;\n};\n\n/**\n * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified\n * since the fill or stroke was last set.\n * @method PIXI.Graphics#c\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.c = p.closePath;\n\n/**\n * Alias for `addHole`\n * @method PIXI.Graphics#h\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.h = p.addHole;\n\n/**\n * Shortcut to `moveTo`.\n * @method PIXI.Graphics#m\n * @param {Number} x The x coordinate the drawing point should move to.\n * @param {Number} y The y coordinate the drawing point should move to.\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls).\n **/\np.m = p.moveTo;\n\n/**\n * Shortcut to `lineTo`.\n * @method PIXI.Graphics#l\n * @param {Number} x The x coordinate the drawing point should draw to.\n * @param {Number} y The y coordinate the drawing point should draw to.\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.l = p.lineTo;\n\n/**\n * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed\n * information, read the <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\">\n * whatwg spec</a>. A tiny API method \"qt\" also exists.\n * @method PIXI.Graphics#q\n * @param {Number} cpx\n * @param {Number} cpy\n * @param {Number} x\n * @param {Number} y\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.q = p.quadraticCurveTo;\n\n/**\n * Shortcut to `bezierCurveTo`.\n * @method PIXI.Graphics#b\n * @param {Number} cp1x\n * @param {Number} cp1y\n * @param {Number} cp2x\n * @param {Number} cp2y\n * @param {Number} x\n * @param {Number} y\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.b = p.bezierCurveTo;\n\n/**\n * Shortcut to `beginFill`.\n * @method PIXI.Graphics#f\n * @param {Uint} color The hex color value (e.g. 0xFFFFFF)\n * null will result in no fill.\n * @param {Number} [alpha=1] The alpha value of fill\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.f = p.beginFill;\n\n/**\n * Shortcut to `lineStyle`.\n * @method PIXI.Graphics#s\n * @param {String} color A CSS compatible color value (ex. \"#FF0000\", \"red\", or \"rgba(255,0,0,0.5)\"). Setting to\n * null will result in no stroke.\n * @param {Number} [thickness=1] The thickness of the stroke\n * @param {Number} [alpha=1] The alpha value from 0 (invisibile) to 1 (visible)\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.s = p.lineStyle;\n\n/**\n * Shortcut to `drawRect`.\n * @method PIXI.Graphics#dr\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w Width of the rectangle\n * @param {Number} h Height of the rectangle\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\n/**\n * Shortcut to `drawRect`.\n * @method PIXI.Graphics#r\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w Width of the rectangle\n * @param {Number} h Height of the rectangle\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.dr = p.drawRect;\n\n/**\n * Shortcut to `drawRoundedRect`.\n * @method PIXI.Graphics#rr\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w Width of the rectangle\n * @param {Number} h Height of the rectangle\n * @param {Number} radius The corner radius\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.rr = p.drawRoundedRect;\n\n/**\n * Shortcut to `drawRoundedRect`.\n * @method PIXI.Graphics#rc\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w Width of the rectangle\n * @param {Number} h Height of the rectangle\n * @param {Number} radiusTL The top left corner radius\n * @param {Number} radiusTR The top right corner radius\n * @param {Number} radiusBR The bottom right corner radius\n * @param {Number} radiusBL The bottom left corner radius\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.rc = p.drawRoundedRect;\n\n/**\n * Shortcut to `drawCircle`.\n * @method PIXI.Graphics#dc\n * @param {Number} x x coordinate center point of circle.\n * @param {Number} y y coordinate center point of circle.\n * @param {Number} radius Radius of circle.\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.dc = p.drawCircle;\n\n/**\n * Shortcut to `arc`.\n * @method PIXI.Graphics#ac\n * @param {Number} x\n * @param {Number} y\n * @param {Number} radius\n * @param {Number} startAngle Measured in radians.\n * @param {Number} endAngle Measured in radians.\n * @param {Boolean} anticlockwise\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.ar = p.arc;\n\n/**\n * Shortcut to `arcTo`.\n * @method PIXI.Graphics#at\n * @param {Number} x1\n * @param {Number} y1\n * @param {Number} x2\n * @param {Number} y2\n * @param {Number} radius\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.at = p.arcTo;\n\n/**\n * Shortcut to `drawEllipse`.\n * @method  PIXI.Graphics#de\n * @param  {Number} x      [description]\n * @param  {Number} y      [description]\n * @param  {Number} width  [description]\n * @param  {Number} height [description]\n */\np.de = p.drawEllipse;\n\n/**\n * Placeholder method for a linear fill. Pixi does not support linear fills,\n * so we just pick the first color in colorArray\n * @method PIXI.Graphics#lf\n * @param {Array} colorArray An array of CSS compatible color values @see `f`\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.lf = function(colorArray) {\n    // @if DEBUG\n    console.warn(\"Linear gradient fills are not supported\");\n    // @endif\n    return this.f(colorArray[0]);\n};\n\n/**\n * Placeholder method for a radial fill. Pixi does not support radial fills,\n * so we just pick the first color in colorArray\n * @method PIXI.Graphics#rf\n * @param {Array} colorArray An array of CSS compatible color values @see `f`\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.rf = function(colorArray) {\n    // @if DEBUG\n    console.warn(\"Radial gradient fills are not supported\");\n    // @endif\n    return this.f(colorArray[0]);\n};\n\n/**\n * Placeholder method for a `beginBitmapFill`. Pixi does not support bitmap fills.\n * @method PIXI.Graphics#bf\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.bf = function() {\n    // @if DEBUG\n    console.warn(\"Bitmap fills are not supported\");\n    // @endif\n    return this.f(0x0);\n};\n\n/**\n * Placeholder method for a `setStrokeDash`. Pixi does not support dashed strokes.\n * @method PIXI.Graphics#sd\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.sd = function() {\n    // @if DEBUG\n    console.warn(\"Dashed strokes are not supported\");\n    // @endif\n    return this;\n};\n\n/**\n * Placeholder method for a `beginBitmapStroke`. Pixi does not support bitmap strokes.\n * @method PIXI.Graphics#bs\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.bs = function() {\n    // @if DEBUG\n    console.warn(\"Bitmap strokes are not supported\");\n    // @endif\n    return this;\n};\n\n/**\n * Placeholder method for a `beginLinearGradientStroke`. Pixi does not support gradient strokes.\n * @method PIXI.Graphics#ls\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.ls = function() {\n    // @if DEBUG\n    console.warn(\"Linear gradient strokes are not supported\");\n    // @endif\n    return this;\n};\n\n/**\n * Placeholder method for a `beginRadialGradientStroke`. Pixi does not support gradient strokes.\n * @method PIXI.Graphics#rs\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.rs = function() {\n    // @if DEBUG\n    console.warn(\"Radial gradient strokes are not supported\");\n    // @endif\n    return this;\n};","/**\n * Mixins for the PIXI.Sprite class.\n * @memberof PIXI\n * @class Sprite\n */\nconst p = PIXI.Sprite.prototype;\n\n/**\n * Extend a container\n * @method PIXI.Sprite.extend\n * @static\n * @param {PIXI.Sprite} child The child function\n * @return {PIXI.Sprite} THe child\n */\n/**\n * Extend a container (shortcut for `extend`)\n * @method PIXI.Sprite.e\n * @static\n * @param {PIXI.Sprite} child The child function\n * @return {PIXI.Sprite} THe child\n */\nPIXI.Sprite.extend = PIXI.Sprite.e = function(child) {\n    child.prototype = Object.create(p);\n    child.prototype.__parent = p;\n    child.prototype.constructor = child;\n    return child;\n};","/**\n * Mixins for the PIXI.Text class.\n * @memberof PIXI\n * @class Text\n */\nconst p = PIXI.Text.prototype;\n\n// Possible align values\nconst ALIGN_VALUES = [\"center\", \"right\"];\n\n/**\n * Setter for the alignment, also sets the anchor point\n * to make sure the positioning is correct.\n * @method PIXI.Text#setAlign\n * @param {String} align Either, center, right, left\n * @return {PIXI.Text} For chaining\n */\n/**\n * Shortcut for `setAlign`.\n * @method PIXI.Text#g\n * @param {String|int} align Either, center (0), right (1), left (-1)\n * @return {PIXI.Text} For chaining\n */\np.setAlign = p.g = function(align) {\n    if (typeof align == \"string\") {\n        align = ALIGN_VALUES.indexOf(align);\n    }\n    this.style.align = ALIGN_VALUES[align] || \"left\";\n    this.anchor.x = (align + 1) / 2;\n    return this;\n};\n\n// Map of short names to long names\nvar STYLE_PROPS = {\n    o: 'font', // TODO: deprecate in Pixi v4\n    z: 'fontSize',\n    f: 'fontFamily',\n    y: 'fontStyle',\n    g: 'fontWeight',\n    i: 'fill',\n    a: 'align',\n    s: 'stroke',\n    t: 'strokeThickness',\n    w: 'wordWrap',\n    d: 'wordWrapWidth',\n    l: 'lineHeight',\n    h: 'dropShadow',\n    c: 'dropShadowColor',\n    n: 'dropShadowAngle',\n    b: 'dropShadowBlur',\n    p: 'padding',\n    x: 'textBaseline',\n    j: 'lineJoin',\n    m: 'miterLimit',\n    e: 'letterSpacing'\n};\n\n/**\n * Set the style, a chainable version of style setter\n * @method PIXI.Text#setStyle\n * @param {Object} style\n * @return {PIXI.Text} instance of text field\n */\n/**\n * Shortcut for `setStyle`.\n * @method PIXI.Text#ss\n * @param {Object} style\n * @return {PIXI.Text} instance of text field\n */\np.setStyle = p.ss = function(style) {\n    // Replace short STYLE_PROPS with long names\n    for (var k in STYLE_PROPS) {\n        if (style[k] !== undefined) {\n            style[STYLE_PROPS[k]] = style[k];\n            delete style[k];\n        }\n    }\n    this.style = style;\n    return this;\n};\n\n/**\n * Initial setting of the drop shadow.\n * @method PIXI.Text#setShadow\n * @param {String} [color=\"#000000\"] The color to set\n * @param {Number} [angle=Math.PI/4] The angle of offset, in radians\n * @param {Number} [distance=5] The offset distance\n * @return {PIXI.Text} For chaining\n */\n/**\n * Shortcut for `setShadow`.\n * @method PIXI.Text#sh\n * @param {String} [color=\"#000000\"] The color to set\n * @param {Number} [angle=Math.PI/4] The angle of offset, in radians\n * @param {Number} [distance=5] The offset distance\n * @return {PIXI.Text} For chaining\n */\np.setShadow = p.sh = function(color, angle, distance) {\n    var style = this.style;\n    style.dropShadow = true;\n\n    // Convert color to hex string\n    if (color !== undefined) {\n        color = \"#\" + color.toString(16);\n    }\n    style.dropShadowColor = isUndefinedOr(color, style.dropShadowColor);\n    style.dropShadowAngle = isUndefinedOr(angle, style.dropShadowAngle);\n    style.dropShadowDistance = isUndefinedOr(distance, style.dropShadowDistance);\n    return this;\n};\n\n/**\n * Check if a value is undefined, fallback to default value\n * @method isUndefinedOr\n * @private\n * @param {*} value The value to check\n * @param {*} defaultValue The default value if value is undefined\n * @return {*} The either the value or the default value\n */\nvar isUndefinedOr = function(value, defaultValue) {\n    return value === undefined ? defaultValue : value;\n};\n","import Container from './Container';\nimport DisplayObject from './DisplayObject';\nimport Sprite from './Sprite';\nimport Graphics from './Graphics';\nimport Text from './Text';\n\n/**\n * @namespace PIXI\n */\nexport default {\n    Container,\n    DisplayObject,\n    Sprite,\n    Graphics,\n    Text\n};","// If we're in the browser make sure PIXI is available\nif (typeof PIXI === 'undefined') {\n    throw \"Requires PIXI\";\n}\n\nif (!PIXI.animate) {\n    // Include the PIXI mixins\n    require('./mixins');\n\n    // Add to the PIXI global object\n    Object.defineProperty(PIXI, 'animate', {\n        enumerable: true,\n        get() { return require('./animate'); }\n    });\n}\n\n// Export for Node-compatible environments like Electron\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = PIXI.animate;\n}\n"],"sourceRoot":"."}